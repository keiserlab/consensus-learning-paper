<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <namespace name="Vips"
             version="8.0"
             shared-library="libvips.so.42"
             c:identifier-prefixes="Vips,vips"
             c:symbol-prefixes="vips">
    <alias name="ArgumentTable" c:type="VipsArgumentTable">
      <type name="GLib.HashTable" c:type="GHashTable"/>
    </alias>
    <alias name="Pel" c:type="VipsPel">
      <doc xml:space="preserve">A picture element. Cast this to whatever the associated VipsBandFormat says
to get the value.</doc>
      <type name="guint8" c:type="unsigned char"/>
    </alias>
    <constant name="ARGUMENT_OPTIONAL_INPUT"
              value="18"
              c:type="VIPS_ARGUMENT_OPTIONAL_INPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_OPTIONAL_OUTPUT"
              value="34"
              c:type="VIPS_ARGUMENT_OPTIONAL_OUTPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_REQUIRED_INPUT"
              value="19"
              c:type="VIPS_ARGUMENT_REQUIRED_INPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_REQUIRED_OUTPUT"
              value="35"
              c:type="VIPS_ARGUMENT_REQUIRED_OUTPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="A_X0" value="109.850300" c:type="VIPS_A_X0">
      <doc xml:space="preserve">Areas under curves for illuminant A (2856K), 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="A_Y0" value="100.000000" c:type="VIPS_A_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="A_Z0" value="35.584900" c:type="VIPS_A_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="Access"
                 glib:type-name="VipsAccess"
                 glib:get-type="vips_access_get_type"
                 c:type="VipsAccess">
      <doc xml:space="preserve">The type of access an operation has to supply. See vips_tilecache()
and #VipsForeign.

@VIPS_ACCESS_RANDOM means requests can come in any order.

@VIPS_ACCESS_SEQUENTIAL means requests will be top-to-bottom, but with some
amount of buffering behind the read point for small non-local accesses.

@VIPS_ACCESS_SEQUENTIAL_UNBUFFERED means requests will be strictly
top-to-bottom with no read-behind. This can save some memory.</doc>
      <member name="random"
              value="0"
              c:identifier="VIPS_ACCESS_RANDOM"
              glib:nick="random">
        <doc xml:space="preserve">can read anywhere</doc>
      </member>
      <member name="sequential"
              value="1"
              c:identifier="VIPS_ACCESS_SEQUENTIAL"
              glib:nick="sequential">
        <doc xml:space="preserve">top-to-bottom reading only, but with a small buffer</doc>
      </member>
      <member name="sequential_unbuffered"
              value="2"
              c:identifier="VIPS_ACCESS_SEQUENTIAL_UNBUFFERED"
              glib:nick="sequential-unbuffered">
        <doc xml:space="preserve">top-to-bottom reading only</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="VIPS_ACCESS_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="Align"
                 glib:type-name="VipsAlign"
                 glib:get-type="vips_align_get_type"
                 c:type="VipsAlign">
      <doc xml:space="preserve">See vips_join() and so on.

Operations like vips_join() need to be told whether to align images on the
low or high coordinate edge, or centre.

See also: vips_join().</doc>
      <member name="low"
              value="0"
              c:identifier="VIPS_ALIGN_LOW"
              glib:nick="low">
        <doc xml:space="preserve">align low coordinate edge</doc>
      </member>
      <member name="centre"
              value="1"
              c:identifier="VIPS_ALIGN_CENTRE"
              glib:nick="centre">
        <doc xml:space="preserve">align centre</doc>
      </member>
      <member name="high"
              value="2"
              c:identifier="VIPS_ALIGN_HIGH"
              glib:nick="high">
        <doc xml:space="preserve">align high coordinate edge</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="VIPS_ALIGN_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="Angle"
                 glib:type-name="VipsAngle"
                 glib:get-type="vips_angle_get_type"
                 c:type="VipsAngle">
      <doc xml:space="preserve">See vips_rot() and so on.

Fixed rotate angles.

See also: vips_rot().</doc>
      <member name="d0" value="0" c:identifier="VIPS_ANGLE_D0" glib:nick="d0">
        <doc xml:space="preserve">no rotate</doc>
      </member>
      <member name="d90"
              value="1"
              c:identifier="VIPS_ANGLE_D90"
              glib:nick="d90">
        <doc xml:space="preserve">90 degrees clockwise</doc>
      </member>
      <member name="d180"
              value="2"
              c:identifier="VIPS_ANGLE_D180"
              glib:nick="d180">
        <doc xml:space="preserve">180 degree rotate</doc>
      </member>
      <member name="d270"
              value="3"
              c:identifier="VIPS_ANGLE_D270"
              glib:nick="d270">
        <doc xml:space="preserve">90 degrees anti-clockwise</doc>
      </member>
      <member name="last"
              value="4"
              c:identifier="VIPS_ANGLE_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="Angle45"
                 glib:type-name="VipsAngle45"
                 glib:get-type="vips_angle45_get_type"
                 c:type="VipsAngle45">
      <doc xml:space="preserve">See vips_rot45() and so on.

Fixed rotate angles.

See also: vips_rot45().</doc>
      <member name="d0"
              value="0"
              c:identifier="VIPS_ANGLE45_D0"
              glib:nick="d0">
        <doc xml:space="preserve">no rotate</doc>
      </member>
      <member name="d45"
              value="1"
              c:identifier="VIPS_ANGLE45_D45"
              glib:nick="d45">
        <doc xml:space="preserve">45 degrees clockwise</doc>
      </member>
      <member name="d90"
              value="2"
              c:identifier="VIPS_ANGLE45_D90"
              glib:nick="d90">
        <doc xml:space="preserve">90 degrees clockwise</doc>
      </member>
      <member name="d135"
              value="3"
              c:identifier="VIPS_ANGLE45_D135"
              glib:nick="d135">
        <doc xml:space="preserve">135 degrees clockwise</doc>
      </member>
      <member name="d180"
              value="4"
              c:identifier="VIPS_ANGLE45_D180"
              glib:nick="d180">
        <doc xml:space="preserve">180 degrees</doc>
      </member>
      <member name="d225"
              value="5"
              c:identifier="VIPS_ANGLE45_D225"
              glib:nick="d225">
        <doc xml:space="preserve">135 degrees anti-clockwise</doc>
      </member>
      <member name="d270"
              value="6"
              c:identifier="VIPS_ANGLE45_D270"
              glib:nick="d270">
        <doc xml:space="preserve">90 degrees anti-clockwise</doc>
      </member>
      <member name="d315"
              value="7"
              c:identifier="VIPS_ANGLE45_D315"
              glib:nick="d315">
        <doc xml:space="preserve">45 degrees anti-clockwise</doc>
      </member>
      <member name="last"
              value="8"
              c:identifier="VIPS_ANGLE45_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <record name="Area"
            c:type="VipsArea"
            glib:type-name="VipsArea"
            glib:get-type="vips_area_get_type"
            c:symbol-prefix="area">
      <field name="data" writable="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="length" writable="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <field name="n" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="count" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="lock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="free_fn" readable="0" private="1">
        <type name="CallbackFn" c:type="VipsCallbackFn"/>
      </field>
      <field name="type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="sizeof_type" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <constructor name="new" c:identifier="vips_area_new">
        <doc xml:space="preserve">A VipsArea wraps a chunk of memory. It adds reference counting and a free
function. It also keeps a count and a %GType, so the area can be an array.

This type is used for things like passing an array of double or an array of
#VipsObject pointers to operations, and for reference-counted immutable
strings.

Inital count == 1, so _unref() after attaching somewhere.

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsArea.</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">@data will be freed with this function</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data will be freed with this function</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array" c:identifier="vips_area_new_array">
        <doc xml:space="preserve">An area which holds an array of elements of some %GType. To set values for
the elements, get the pointer and write.

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsArea.</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">%GType of elements to store</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="sizeof_type" transfer-ownership="none">
            <doc xml:space="preserve">sizeof() an element in the array</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of elements in the array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array_object"
                   c:identifier="vips_area_new_array_object">
        <doc xml:space="preserve">An area which holds an array of %GObject s. See vips_area_new_array(). When
the area is freed, each %GObject will be unreffed.

Add an extra NULL element at the end, handy for eg.
vips_image_pipeline_array() etc.

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsArea.</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of elements in the array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="vips_area_copy">
        <return-value transfer-ownership="full">
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <type name="Area" c:type="VipsArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="vips_area_get_data">
        <doc xml:space="preserve">Return the data pointer plus optionally the length in bytes of an area,
the number of elements, the %GType of each element and the sizeof() each
element.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The pointer held by @area.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">#VipsArea to fetch from</doc>
            <type name="Area" c:type="VipsArea*"/>
          </instance-parameter>
          <parameter name="length"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optionally return length in bytes here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="n"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optionally return number of elements here</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optionally return element type here</doc>
            <type name="GType" c:type="GType*"/>
          </parameter>
          <parameter name="sizeof_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optionally return sizeof() element type here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="vips_area_unref">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <type name="Area" c:type="VipsArea*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Argument" c:type="VipsArgument">
      <field name="pspec" writable="1">
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </field>
      <function name="map" c:identifier="vips_argument_map" introspectable="0">
        <doc xml:space="preserve">Loop over the vips_arguments to an object. Stop when @fn returns non-%NULL
and return that value.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first
non-%NULL value from @fn.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object whose args should be enumerated</doc>
            <type name="Object" c:type="VipsObject*"/>
          </parameter>
          <parameter name="fn" transfer-ownership="none">
            <doc xml:space="preserve">call this function for every argument</doc>
            <type name="ArgumentMapFn" c:type="VipsArgumentMapFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ArgumentClass" c:type="VipsArgumentClass">
      <field name="parent" writable="1">
        <type name="Argument" c:type="VipsArgument"/>
      </field>
      <field name="object_class" writable="1">
        <type name="ObjectClass" c:type="VipsObjectClass*"/>
      </field>
      <field name="flags" writable="1">
        <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
      </field>
      <field name="priority" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="offset" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="needsstring"
              c:identifier="vips_argument_class_needsstring">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="argument_class" transfer-ownership="none">
            <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="map"
                c:identifier="vips_argument_class_map"
                introspectable="0">
        <doc xml:space="preserve">And loop over a class. Same as ^^, but with no VipsArgumentInstance.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object_class" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="fn" transfer-ownership="none">
            <type name="ArgumentClassMapFn" c:type="VipsArgumentClassMapFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="ArgumentClassMapFn" c:type="VipsArgumentClassMapFn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object_class" transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="argument_class" transfer-ownership="none">
          <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="ArgumentFlags"
              glib:type-name="VipsArgumentFlags"
              glib:get-type="vips_argument_flags_get_type"
              c:type="VipsArgumentFlags">
      <doc xml:space="preserve">Flags we associate with each object argument.

Have separate input &amp; output flags. Both set is an error; neither set is OK.

Input gobjects are automatically reffed, output gobjects automatically ref
us. We also automatically watch for "destroy" and unlink.

@VIPS_ARGUMENT_SET_ALWAYS is handy for arguments which are set from C. For
example, VipsImage::width is a property that gives access to the Xsize
member of struct _VipsImage. We default its 'assigned' to TRUE
since the field is always set directly by C.

@VIPS_ARGUMENT_DEPRECATED arguments are not shown in help text, are not
looked for if required, are not checked for "have-been-set". You can
deprecate a required argument, but you must obviously add a new required
argument if you do.

Input args with @VIPS_ARGUMENT_MODIFY will be modified by the operation.
This is used for things like the in-place drawing operations.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_ARGUMENT_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flags</doc>
      </member>
      <member name="required"
              value="1"
              c:identifier="VIPS_ARGUMENT_REQUIRED"
              glib:nick="required">
        <doc xml:space="preserve">must be set in the constructor</doc>
      </member>
      <member name="construct"
              value="2"
              c:identifier="VIPS_ARGUMENT_CONSTRUCT"
              glib:nick="construct">
        <doc xml:space="preserve">can only be set in the constructor</doc>
      </member>
      <member name="set_once"
              value="4"
              c:identifier="VIPS_ARGUMENT_SET_ONCE"
              glib:nick="set-once">
        <doc xml:space="preserve">can only be set once</doc>
      </member>
      <member name="set_always"
              value="8"
              c:identifier="VIPS_ARGUMENT_SET_ALWAYS"
              glib:nick="set-always">
        <doc xml:space="preserve">don't do use-before-set checks</doc>
      </member>
      <member name="input"
              value="16"
              c:identifier="VIPS_ARGUMENT_INPUT"
              glib:nick="input">
        <doc xml:space="preserve">is an input argument (one we depend on)</doc>
      </member>
      <member name="output"
              value="32"
              c:identifier="VIPS_ARGUMENT_OUTPUT"
              glib:nick="output">
        <doc xml:space="preserve">is an output argument (depends on us)</doc>
      </member>
      <member name="deprecated"
              value="64"
              c:identifier="VIPS_ARGUMENT_DEPRECATED"
              glib:nick="deprecated">
        <doc xml:space="preserve">just there for back-compat, hide</doc>
      </member>
      <member name="modify"
              value="128"
              c:identifier="VIPS_ARGUMENT_MODIFY"
              glib:nick="modify">
        <doc xml:space="preserve">the input argument will be modified</doc>
      </member>
    </bitfield>
    <record name="ArgumentInstance" c:type="VipsArgumentInstance">
      <field name="parent" writable="1">
        <type name="Argument" c:type="VipsArgument"/>
      </field>
      <field name="argument_class" writable="1">
        <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
      </field>
      <field name="object" writable="1">
        <type name="Object" c:type="VipsObject*"/>
      </field>
      <field name="assigned" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="close_id" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="invalidate_id" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
    </record>
    <callback name="ArgumentMapFn" c:type="VipsArgumentMapFn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="argument_class" transfer-ownership="none">
          <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter name="argument_instance" transfer-ownership="none">
          <type name="ArgumentInstance" c:type="VipsArgumentInstance*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ArrayDouble"
            c:type="VipsArrayDouble"
            glib:type-name="VipsArrayDouble"
            glib:get-type="vips_array_double_get_type"
            c:symbol-prefix="array_double">
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_array_double_new">
        <doc xml:space="preserve">Allocate a new array of doubles and copy @array into it. Free with
vips_area_unref().

See also: #VipsArea.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayDouble.</doc>
          <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">array of double</doc>
            <array length="1" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of doubles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv"
                   c:identifier="vips_array_double_newv"
                   introspectable="0">
        <doc xml:space="preserve">Allocate a new array of @n doubles and copy @... into it. Free with
vips_area_unref().

See also: vips_array_double_new()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayDouble.</doc>
          <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of doubles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">list of double arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_array_double_get">
        <doc xml:space="preserve">Fetch a double array from a #VipsArrayDouble. Useful for language bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">array of double</doc>
          <array length="0" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the #VipsArrayDouble to fetch from</doc>
            <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
          </instance-parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">length of array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ArrayImage"
            c:type="VipsArrayImage"
            glib:type-name="VipsArrayImage"
            glib:get-type="vips_array_image_get_type"
            c:symbol-prefix="array_image">
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_array_image_new">
        <doc xml:space="preserve">Allocate a new array of images and copy @array into it. Free with
vips_area_unref().

The images will all be reffed by this function. They
will be automatically unreffed for you by
vips_area_unref().

Add an extra NULL element at the end, handy for eg.
vips_image_pipeline_array() etc.

See also: #VipsArea.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayImage.</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">array of #VipsImage</doc>
            <array length="1" zero-terminated="0" c:type="VipsImage**">
              <type name="Image" c:type="VipsImage*"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of images</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv"
                   c:identifier="vips_array_image_newv"
                   introspectable="0">
        <doc xml:space="preserve">Allocate a new array of @n #VipsImage and copy @... into it. Free with
vips_area_unref().

The images will all be reffed by this function. They
will be automatically unreffed for you by
vips_area_unref().

Add an extra NULL element at the end, handy for eg.
vips_image_pipeline_array() etc.

See also: vips_array_image_new()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayImage.</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of images</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">list of #VipsImage arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="vips_array_image_append">
        <doc xml:space="preserve">Make a new #VipsArrayImage, one larger than @array, with @image appended
to the end.
Handy with vips_array_image_empty() for bindings
which can't handle object array arguments.

See also: vips_array_image_empty().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayImage.</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">append to this</doc>
            <type name="ArrayImage" c:type="VipsArrayImage*"/>
          </instance-parameter>
          <parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">add this</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="vips_array_image_get">
        <doc xml:space="preserve">Fetch an image array from a #VipsArrayImage. Useful for language bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">array of #VipsImage</doc>
          <array length="0" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the #VipsArrayImage to fetch from</doc>
            <type name="ArrayImage" c:type="VipsArrayImage*"/>
          </instance-parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">length of array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <function name="empty" c:identifier="vips_array_image_empty">
        <doc xml:space="preserve">Make an empty image array.
Handy with vips_array_image_add() for bindings
which can't handle object array arguments.

See also: vips_array_image_add().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayImage.</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
      </function>
    </record>
    <record name="ArrayInt"
            c:type="VipsArrayInt"
            glib:type-name="VipsArrayInt"
            glib:get-type="vips_array_int_get_type"
            c:symbol-prefix="array_int">
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_array_int_new">
        <doc xml:space="preserve">Allocate a new array of ints and copy @array into it. Free with
vips_area_unref().

See also: #VipsArea.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayInt.</doc>
          <type name="ArrayInt" c:type="VipsArrayInt*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">array of int</doc>
            <array length="1" zero-terminated="0" c:type="int*">
              <type name="gint" c:type="int"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of ints</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv"
                   c:identifier="vips_array_int_newv"
                   introspectable="0">
        <doc xml:space="preserve">Allocate a new array of @n ints and copy @... into it. Free with
vips_area_unref().

See also: vips_array_int_new()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #VipsArrayInt.</doc>
          <type name="ArrayInt" c:type="VipsArrayInt*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of ints</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">list of int arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_array_int_get">
        <doc xml:space="preserve">Fetch an int array from a #VipsArrayInt. Useful for language bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">array of int</doc>
          <array length="0" zero-terminated="0" c:type="int*">
            <type name="gint" c:type="int"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the #VipsArrayInt to fetch from</doc>
            <type name="ArrayInt" c:type="VipsArrayInt*"/>
          </instance-parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">length of array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <constant name="B_X0" value="99.072000" c:type="VIPS_B_X0">
      <doc xml:space="preserve">Areas under curves for illuminant B (4874K), 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="B_Y0" value="100.000000" c:type="VIPS_B_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="B_Z0" value="85.223000" c:type="VIPS_B_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="BandFormat"
                 glib:type-name="VipsBandFormat"
                 glib:get-type="vips_band_format_get_type"
                 c:type="VipsBandFormat">
      <doc xml:space="preserve">The format used for each band element.

Each corresponds to a native C type for the current machine. For example,
#VIPS_FORMAT_USHORT is &lt;type&gt;unsigned short&lt;/type&gt;.</doc>
      <member name="notset"
              value="-1"
              c:identifier="VIPS_FORMAT_NOTSET"
              glib:nick="notset">
        <doc xml:space="preserve">invalid setting</doc>
      </member>
      <member name="uchar"
              value="0"
              c:identifier="VIPS_FORMAT_UCHAR"
              glib:nick="uchar">
        <doc xml:space="preserve">unsigned char format</doc>
      </member>
      <member name="char"
              value="1"
              c:identifier="VIPS_FORMAT_CHAR"
              glib:nick="char">
        <doc xml:space="preserve">char format</doc>
      </member>
      <member name="ushort"
              value="2"
              c:identifier="VIPS_FORMAT_USHORT"
              glib:nick="ushort">
        <doc xml:space="preserve">unsigned short format</doc>
      </member>
      <member name="short"
              value="3"
              c:identifier="VIPS_FORMAT_SHORT"
              glib:nick="short">
        <doc xml:space="preserve">short format</doc>
      </member>
      <member name="uint"
              value="4"
              c:identifier="VIPS_FORMAT_UINT"
              glib:nick="uint">
        <doc xml:space="preserve">unsigned int format</doc>
      </member>
      <member name="int"
              value="5"
              c:identifier="VIPS_FORMAT_INT"
              glib:nick="int">
        <doc xml:space="preserve">int format</doc>
      </member>
      <member name="float"
              value="6"
              c:identifier="VIPS_FORMAT_FLOAT"
              glib:nick="float">
        <doc xml:space="preserve">float format</doc>
      </member>
      <member name="complex"
              value="7"
              c:identifier="VIPS_FORMAT_COMPLEX"
              glib:nick="complex">
        <doc xml:space="preserve">complex (two floats) format</doc>
      </member>
      <member name="double"
              value="8"
              c:identifier="VIPS_FORMAT_DOUBLE"
              glib:nick="double">
        <doc xml:space="preserve">double float format</doc>
      </member>
      <member name="dpcomplex"
              value="9"
              c:identifier="VIPS_FORMAT_DPCOMPLEX"
              glib:nick="dpcomplex">
        <doc xml:space="preserve">double complex (two double) format</doc>
      </member>
      <member name="last"
              value="10"
              c:identifier="VIPS_FORMAT_LAST"
              glib:nick="last">
      </member>
      <function name="is8bit" c:identifier="vips_band_format_is8bit">
        <doc xml:space="preserve">Return %TRUE if @format is uchar or schar.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="iscomplex" c:identifier="vips_band_format_iscomplex">
        <doc xml:space="preserve">Return %TRUE if @fmt is one of the complex types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isfloat" c:identifier="vips_band_format_isfloat">
        <doc xml:space="preserve">Return %TRUE if @format is one of the float types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isint" c:identifier="vips_band_format_isint">
        <doc xml:space="preserve">Return %TRUE if @format is one of the integer types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isuint" c:identifier="vips_band_format_isuint">
        <doc xml:space="preserve">Return %TRUE if @format is one of the unsigned integer types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <record name="Blob"
            c:type="VipsBlob"
            glib:type-name="VipsBlob"
            glib:get-type="vips_blob_get_type"
            c:symbol-prefix="blob">
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_blob_new">
        <doc xml:space="preserve">Like vips_area_new(), but track a length as well. The returned #VipsBlob
takes ownership of @data and will free it with @free_fn. Pass NULL for
@free_fn to not transfer ownership.

An area of mem with a free func and a length (some sort of binary object,
like an ICC profile).

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsBlob.</doc>
          <type name="Blob" c:type="VipsBlob*"/>
        </return-value>
        <parameters>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">@data will be freed with this function</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">data to store</doc>
            <array length="2" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes in @data</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_blob_get">
        <doc xml:space="preserve">Get the data from a #VipsBlob.

See also: vips_blob_new().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data</doc>
          <array length="0" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="blob" transfer-ownership="none">
            <doc xml:space="preserve">#VipsBlob to fetch from</doc>
            <type name="Blob" c:type="VipsBlob*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return number of bytes of data</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="copy" c:identifier="vips_blob_copy">
        <doc xml:space="preserve">Like vips_blob_new(), but take a copy of the data. Useful for bindings
which strugle with callbacks.

See also: vips_blob_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsBlob.</doc>
          <type name="Blob" c:type="VipsBlob*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data to store</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes in @data</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function name="CMC2LCh" c:identifier="vips_CMC2LCh" introspectable="0">
      <doc xml:space="preserve">Turn LCh to CMC.

See also: vips_LCh2CMC().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="CMC2XYZ" c:identifier="vips_CMC2XYZ" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <constant name="C_X0" value="98.070000" c:type="VIPS_C_X0">
      <doc xml:space="preserve">Areas under curves for illuminant C (6774K), 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="C_Y0" value="100.000000" c:type="VIPS_C_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="C_Z0" value="118.230000" c:type="VIPS_C_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <callback name="CallbackFn" c:type="VipsCallbackFn">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClassMapFn" c:type="VipsClassMapFn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Coding"
                 glib:type-name="VipsCoding"
                 glib:get-type="vips_coding_get_type"
                 c:type="VipsCoding">
      <doc xml:space="preserve">How pixels are coded.

Normally, pixels are uncoded and can be manipulated as you would expect.
However some file formats code pixels for compression, and sometimes it's
useful to be able to manipulate images in the coded format.

The gaps in the numbering are historical and must be maintained. Allocate
new numbers from the end.</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_CODING_ERROR"
              glib:nick="error">
      </member>
      <member name="none"
              value="0"
              c:identifier="VIPS_CODING_NONE"
              glib:nick="none">
        <doc xml:space="preserve">pixels are not coded</doc>
      </member>
      <member name="labq"
              value="2"
              c:identifier="VIPS_CODING_LABQ"
              glib:nick="labq">
        <doc xml:space="preserve">pixels encode 3 float CIELAB values as 4 uchar</doc>
      </member>
      <member name="rad"
              value="6"
              c:identifier="VIPS_CODING_RAD"
              glib:nick="rad">
        <doc xml:space="preserve">pixels encode 3 float RGB as 4 uchar (Radiance coding)</doc>
      </member>
      <member name="last"
              value="7"
              c:identifier="VIPS_CODING_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="Combine"
                 glib:type-name="VipsCombine"
                 glib:get-type="vips_combine_get_type"
                 c:type="VipsCombine">
      <doc xml:space="preserve">How to combine values.</doc>
      <member name="max"
              value="0"
              c:identifier="VIPS_COMBINE_MAX"
              glib:nick="max">
        <doc xml:space="preserve">take the maximum of the possible values</doc>
      </member>
      <member name="sum"
              value="1"
              c:identifier="VIPS_COMBINE_SUM"
              glib:nick="sum">
        <doc xml:space="preserve">sum all the values</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_COMBINE_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="CombineMode"
                 glib:type-name="VipsCombineMode"
                 glib:get-type="vips_combine_mode_get_type"
                 c:type="VipsCombineMode">
      <doc xml:space="preserve">See vips_draw_image() and so on.

Operations like vips_draw_image() need to be told how to combine images
from two sources.

See also: vips_join().</doc>
      <member name="set"
              value="0"
              c:identifier="VIPS_COMBINE_MODE_SET"
              glib:nick="set">
        <doc xml:space="preserve">set pixels to the new value</doc>
      </member>
      <member name="add"
              value="1"
              c:identifier="VIPS_COMBINE_MODE_ADD"
              glib:nick="add">
        <doc xml:space="preserve">add pixels</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_COMBINE_MODE_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <constant name="D3250_X0" value="105.659000" c:type="VIPS_D3250_X0">
      <doc xml:space="preserve">Areas under curves for black body at 3250K, 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D3250_Y0" value="100.000000" c:type="VIPS_D3250_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D3250_Z0" value="45.850100" c:type="VIPS_D3250_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D50_X0" value="96.425000" c:type="VIPS_D50_X0">
      <doc xml:space="preserve">Areas under curves for D50, 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D50_Y0" value="100.000000" c:type="VIPS_D50_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D50_Z0" value="82.468000" c:type="VIPS_D50_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D55_X0" value="95.683100" c:type="VIPS_D55_X0">
      <doc xml:space="preserve">Areas under curves for D55, 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D55_Y0" value="100.000000" c:type="VIPS_D55_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D55_Z0" value="92.087100" c:type="VIPS_D55_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D65_X0" value="95.047000" c:type="VIPS_D65_X0">
      <doc xml:space="preserve">Areas under curves for D65, 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D65_Y0" value="100.000000" c:type="VIPS_D65_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D65_Z0" value="108.882700" c:type="VIPS_D65_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D75_X0" value="94.968200" c:type="VIPS_D75_X0">
      <doc xml:space="preserve">Areas under curves for D75, 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D75_Y0" value="100.000000" c:type="VIPS_D75_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D75_Z0" value="122.571000" c:type="VIPS_D75_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D93_X0" value="89.740000" c:type="VIPS_D93_X0">
      <doc xml:space="preserve">Areas under curves for D93, 2 degree observer.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D93_Y0" value="100.000000" c:type="VIPS_D93_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D93_Z0" value="130.770000" c:type="VIPS_D93_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="DemandStyle"
                 glib:type-name="VipsDemandStyle"
                 glib:get-type="vips_demand_style_get_type"
                 c:type="VipsDemandStyle">
      <doc xml:space="preserve">See vips_image_pipelinev(). Operations can hint to the VIPS image IO
system about the kind of demand geometry they prefer.

These demand styles are given below in order of increasing
restrictiveness.  When demanding output from a pipeline,
vips_image_generate()
will use the most restrictive of the styles requested by the operations
in the pipeline.

#VIPS_DEMAND_STYLE_THINSTRIP --- This operation would like to output strips
the width of the image and a few pels high. This is option suitable for
point-to-point operations, such as those in the arithmetic package.

This option is only efficient for cases where each output pel depends
upon the pel in the corresponding position in the input image.

#VIPS_DEMAND_STYLE_FATSTRIP --- This operation would like to output strips
the width of the image and as high as possible. This option is suitable
for area operations which do not violently transform coordinates, such
as vips_conv().

#VIPS_DEMAND_STYLE_SMALLTILE --- This is the most general demand format.
Output is demanded in small (around 100x100 pel) sections. This style works
reasonably efficiently, even for bizzare operations like 45 degree rotate.

#VIPS_DEMAND_STYLE_ANY --- This image is not being demand-read from a disc
file (even indirectly) so any demand style is OK. It's used for things like
vips_black() where the pixels are calculated.

See also: vips_image_pipelinev().</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_DEMAND_STYLE_ERROR"
              glib:nick="error">
      </member>
      <member name="smalltile"
              value="0"
              c:identifier="VIPS_DEMAND_STYLE_SMALLTILE"
              glib:nick="smalltile">
        <doc xml:space="preserve">demand in small (typically 64x64 pixel) tiles</doc>
      </member>
      <member name="fatstrip"
              value="1"
              c:identifier="VIPS_DEMAND_STYLE_FATSTRIP"
              glib:nick="fatstrip">
        <doc xml:space="preserve">demand in fat (typically 10 pixel high) strips</doc>
      </member>
      <member name="thinstrip"
              value="2"
              c:identifier="VIPS_DEMAND_STYLE_THINSTRIP"
              glib:nick="thinstrip">
        <doc xml:space="preserve">demand in thin (typically 1 pixel high) strips</doc>
      </member>
      <member name="any"
              value="3"
              c:identifier="VIPS_DEMAND_STYLE_ANY"
              glib:nick="any">
        <doc xml:space="preserve">demand geometry does not matter</doc>
      </member>
    </enumeration>
    <enumeration name="Direction"
                 glib:type-name="VipsDirection"
                 glib:get-type="vips_direction_get_type"
                 c:type="VipsDirection">
      <doc xml:space="preserve">See vips_flip(), vips_join() and so on.

Operations like vips_flip() need to be told whether to flip left-right or
top-bottom.

See also: vips_flip(), vips_join().</doc>
      <member name="horizontal"
              value="0"
              c:identifier="VIPS_DIRECTION_HORIZONTAL"
              glib:nick="horizontal">
        <doc xml:space="preserve">left-right</doc>
      </member>
      <member name="vertical"
              value="1"
              c:identifier="VIPS_DIRECTION_VERTICAL"
              glib:nick="vertical">
        <doc xml:space="preserve">top-bottom</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_DIRECTION_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <constant name="E_X0" value="100.000000" c:type="VIPS_E_X0">
      <doc xml:space="preserve">Areas under curves for equal energy illuminant E.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="E_Y0" value="100.000000" c:type="VIPS_E_Y0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="E_Z0" value="100.000000" c:type="VIPS_E_Z0">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="Extend"
                 glib:type-name="VipsExtend"
                 glib:get-type="vips_extend_get_type"
                 c:type="VipsExtend">
      <doc xml:space="preserve">See vips_embed(), vips_conv(), vips_affine() and so on.

When the edges of an image are extended, you can specify
how you want the extension done.

#VIPS_EXTEND_BLACK --- new pixels are black, ie. all bits are zero.

#VIPS_EXTEND_COPY --- each new pixel takes the value of the nearest edge
pixel

#VIPS_EXTEND_REPEAT --- the image is tiled to fill the new area

#VIPS_EXTEND_MIRROR --- the image is reflected and tiled to reduce hash
edges

#VIPS_EXTEND_WHITE --- new pixels are white, ie. all bits are set

#VIPS_EXTEND_BACKGROUND --- colour set from the @background property

We have to specify the exact value of each enum member since we have to
keep these frozen for back compat with vips7.

See also: vips_embed().</doc>
      <member name="black"
              value="0"
              c:identifier="VIPS_EXTEND_BLACK"
              glib:nick="black">
        <doc xml:space="preserve">extend with black (all 0) pixels</doc>
      </member>
      <member name="copy"
              value="1"
              c:identifier="VIPS_EXTEND_COPY"
              glib:nick="copy">
        <doc xml:space="preserve">copy the image edges</doc>
      </member>
      <member name="repeat"
              value="2"
              c:identifier="VIPS_EXTEND_REPEAT"
              glib:nick="repeat">
        <doc xml:space="preserve">repeat the whole image</doc>
      </member>
      <member name="mirror"
              value="3"
              c:identifier="VIPS_EXTEND_MIRROR"
              glib:nick="mirror">
        <doc xml:space="preserve">mirror the whole image</doc>
      </member>
      <member name="white"
              value="4"
              c:identifier="VIPS_EXTEND_WHITE"
              glib:nick="white">
        <doc xml:space="preserve">extend with white (all bits set) pixels</doc>
      </member>
      <member name="background"
              value="5"
              c:identifier="VIPS_EXTEND_BACKGROUND"
              glib:nick="background">
        <doc xml:space="preserve">extend with colour from the @background property</doc>
      </member>
      <member name="last"
              value="6"
              c:identifier="VIPS_EXTEND_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <class name="Foreign"
           c:symbol-prefix="foreign"
           c:type="VipsForeign"
           parent="Operation"
           abstract="1"
           glib:type-name="VipsForeign"
           glib:get-type="vips_foreign_get_type"
           glib:type-struct="ForeignClass">
      <function name="find_load" c:identifier="vips_foreign_find_load">
        <doc xml:space="preserve">Searches for an operation you could use to load @filename. Any trailing
options on @filename are stripped and ignored.

See also: vips_foreign_find_load_buffer(), vips_image_new_from_file().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of an operation on success, %NULL on error</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">file to find a loader for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_load_buffer"
                c:identifier="vips_foreign_find_load_buffer">
        <doc xml:space="preserve">Searches for an operation you could use to load a memory buffer.

See also: vips_image_new_from_buffer().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of an operation on success, %NULL on
error.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">start of
memory buffer</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes in @data</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_save" c:identifier="vips_foreign_find_save">
        <doc xml:space="preserve">Searches for an operation you could use to write to @filename.
Any trailing options on @filename are stripped and ignored.

See also: vips_foreign_find_save_buffer(), vips_image_write_to_file().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of an operation on success, %NULL on error</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">name to find a saver for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_save_buffer"
                c:identifier="vips_foreign_find_save_buffer">
        <doc xml:space="preserve">Searches for an operation you could use to write to a buffer in @suffix
format.

See also: vips_image_write_to_buffer().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of an operation on success, %NULL on error</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="suffix" transfer-ownership="none">
            <doc xml:space="preserve">name to find a saver for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_a" c:identifier="vips_foreign_is_a">
        <doc xml:space="preserve">Return %TRUE if @filename can be loaded by @loader. @loader is something
like "tiffload" or "VipsForeignLoadTiff".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @filename can be loaded by @loader.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="loader" transfer-ownership="none">
            <doc xml:space="preserve">name of loader to use for test</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">file to test</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_a_buffer" c:identifier="vips_foreign_is_a_buffer">
        <doc xml:space="preserve">Return %TRUE if @data can be loaded by @loader. @loader is something
like "tiffload_buffer" or "VipsForeignLoadTiffBuffer".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data can be loaded by @loader.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="loader" transfer-ownership="none">
            <doc xml:space="preserve">name of loader to use for test</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to the buffer to test</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer to test</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </function>
      <function name="map" c:identifier="vips_foreign_map">
        <doc xml:space="preserve">Apply a function to every #VipsForeignClass that VIPS knows about. Foreigns
are presented to the function in priority order.

Like all VIPS map functions, if @fn returns %NULL, iteration continues. If
it returns non-%NULL, iteration terminates and that value is returned. The
map function returns %NULL if all calls return %NULL.

See also: vips_slist_map().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the result of iteration</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve">base class to search below (eg. "VipsForeignLoad")</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fn" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">function to apply to each #VipsForeignClass</doc>
            <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <field name="parent_object">
        <type name="Operation" c:type="VipsOperation"/>
      </field>
    </class>
    <record name="ForeignClass"
            c:type="VipsForeignClass"
            glib:is-gtype-struct-for="Foreign">
      <doc xml:space="preserve">The suffix list is used to select a format to save a file in, and to pick a
loader if you don't define is_a().

You should also define @nickname and @description in #VipsObject.</doc>
      <field name="parent_class">
        <type name="OperationClass" c:type="VipsOperationClass"/>
      </field>
      <field name="priority">
        <type name="gint" c:type="int"/>
      </field>
      <field name="suffs">
        <type name="utf8" c:type="const char**"/>
      </field>
    </record>
    <enumeration name="ForeignDzContainer"
                 glib:type-name="VipsForeignDzContainer"
                 glib:get-type="vips_foreign_dz_container_get_type"
                 c:type="VipsForeignDzContainer">
      <doc xml:space="preserve">How many pyramid layers to create.</doc>
      <member name="fs"
              value="0"
              c:identifier="VIPS_FOREIGN_DZ_CONTAINER_FS"
              glib:nick="fs">
        <doc xml:space="preserve">write tiles to the filesystem</doc>
      </member>
      <member name="zip"
              value="1"
              c:identifier="VIPS_FOREIGN_DZ_CONTAINER_ZIP"
              glib:nick="zip">
        <doc xml:space="preserve">write tiles to a zip file</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_FOREIGN_DZ_CONTAINER_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="ForeignDzDepth"
                 glib:type-name="VipsForeignDzDepth"
                 glib:get-type="vips_foreign_dz_depth_get_type"
                 c:type="VipsForeignDzDepth">
      <doc xml:space="preserve">How many pyramid layers to create.</doc>
      <member name="onepixel"
              value="0"
              c:identifier="VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL"
              glib:nick="onepixel">
        <doc xml:space="preserve">create layers down to 1x1 pixel</doc>
      </member>
      <member name="onetile"
              value="1"
              c:identifier="VIPS_FOREIGN_DZ_DEPTH_ONETILE"
              glib:nick="onetile">
        <doc xml:space="preserve">create layers down to 1x1 tile</doc>
      </member>
      <member name="one"
              value="2"
              c:identifier="VIPS_FOREIGN_DZ_DEPTH_ONE"
              glib:nick="one">
        <doc xml:space="preserve">only create a single layer</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="VIPS_FOREIGN_DZ_DEPTH_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="ForeignDzLayout"
                 glib:type-name="VipsForeignDzLayout"
                 glib:get-type="vips_foreign_dz_layout_get_type"
                 c:type="VipsForeignDzLayout">
      <doc xml:space="preserve">What directory layout and metadata standard to use.</doc>
      <member name="dz"
              value="0"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_DZ"
              glib:nick="dz">
        <doc xml:space="preserve">use DeepZoom directory layout</doc>
      </member>
      <member name="zoomify"
              value="1"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY"
              glib:nick="zoomify">
        <doc xml:space="preserve">use Zoomify directory layout</doc>
      </member>
      <member name="google"
              value="2"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_GOOGLE"
              glib:nick="google">
        <doc xml:space="preserve">use Google maps directory layout</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <bitfield name="ForeignFlags"
              glib:type-name="VipsForeignFlags"
              glib:get-type="vips_foreign_flags_get_type"
              c:type="VipsForeignFlags">
      <doc xml:space="preserve">Some hints about the image loader.

@VIPS_FOREIGN_PARTIAL means that the image can be read directly from the
file without needing to be unpacked to a temporary image first.

@VIPS_FOREIGN_SEQUENTIAL means that the loader supports lazy reading, but
only top-to-bottom (sequential) access. Formats like PNG can read sets of
scanlines, for example, but only in order.

If neither PARTIAL or SEQUENTIAL is set, the loader only supports whole
image read. Setting both PARTIAL and SEQUENTIAL is an error.

@VIPS_FOREIGN_BIGENDIAN means that image pixels are most-significant byte
first. Depending on the native byte order of the host machine, you may
need to swap bytes. See vips_copy().</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FOREIGN_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flags set</doc>
      </member>
      <member name="partial"
              value="1"
              c:identifier="VIPS_FOREIGN_PARTIAL"
              glib:nick="partial">
        <doc xml:space="preserve">the image may be read lazilly</doc>
      </member>
      <member name="bigendian"
              value="2"
              c:identifier="VIPS_FOREIGN_BIGENDIAN"
              glib:nick="bigendian">
        <doc xml:space="preserve">image pixels are most-significant byte first</doc>
      </member>
      <member name="sequential"
              value="4"
              c:identifier="VIPS_FOREIGN_SEQUENTIAL"
              glib:nick="sequential">
        <doc xml:space="preserve">top-to-bottom lazy reading</doc>
      </member>
      <member name="all"
              value="7"
              c:identifier="VIPS_FOREIGN_ALL"
              glib:nick="all">
      </member>
    </bitfield>
    <class name="ForeignLoad"
           c:symbol-prefix="foreign_load"
           c:type="VipsForeignLoad"
           parent="Foreign"
           abstract="1"
           glib:type-name="VipsForeignLoad"
           glib:get-type="vips_foreign_load_get_type"
           glib:type-struct="ForeignLoadClass">
      <doc xml:space="preserve">@header() must set at least the header fields of @out. @load(), if defined,
must load the pixels to @real.</doc>
      <virtual-method name="get_flags">
        <return-value transfer-ownership="none">
          <type name="ForeignFlags" c:type="VipsForeignFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="load" transfer-ownership="none">
            <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="header">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="load" transfer-ownership="none">
            <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="load">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="load" transfer-ownership="none">
            <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <property name="access" writable="1" transfer-ownership="none">
        <type name="Access"/>
      </property>
      <property name="disc" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="flags" writable="1" transfer-ownership="none">
        <type name="ForeignFlags"/>
      </property>
      <property name="out" writable="1" transfer-ownership="none">
        <type name="Image"/>
      </property>
      <property name="sequential" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_object">
        <type name="Foreign" c:type="VipsForeign"/>
      </field>
      <field name="disc" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="access" readable="0" private="1">
        <type name="Access" c:type="VipsAccess"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="ForeignFlags" c:type="VipsForeignFlags"/>
      </field>
      <field name="sequential" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="out">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="real">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="nocache">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <record name="ForeignLoadClass"
            c:type="VipsForeignLoadClass"
            glib:is-gtype-struct-for="ForeignLoad">
      <doc xml:space="preserve">Add a new loader to VIPS by subclassing #VipsForeignLoad. Subclasses need to
implement at least @header().

As a complete example, here's code for a PNG loader, minus the actual
calls to libpng.

|[
typedef struct _VipsForeignLoadPng {
  VipsForeignLoad parent_object;

  char *filename;
} VipsForeignLoadPng;

typedef VipsForeignLoadClass VipsForeignLoadPngClass;

G_DEFINE_TYPE( VipsForeignLoadPng, vips_foreign_load_png,
  VIPS_TYPE_FOREIGN_LOAD );

static VipsForeignFlags
vips_foreign_load_png_get_flags_filename( const char *filename )
{
  VipsForeignFlags flags;

  flags = 0;
  if( vips__png_isinterlaced( filename ) )
  	flags = VIPS_FOREIGN_PARTIAL;
  else
  	flags = VIPS_FOREIGN_SEQUENTIAL;

  return( flags );
}

static VipsForeignFlags
vips_foreign_load_png_get_flags( VipsForeignLoad *load )
{
  VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;

  return( vips_foreign_load_png_get_flags_filename( png-&gt;filename ) );
}

static int
vips_foreign_load_png_header( VipsForeignLoad *load )
{
  VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;

  if( vips__png_header( png-&gt;filename, load-&gt;out ) )
  	return( -1 );

  return( 0 );
}

static int
vips_foreign_load_png_load( VipsForeignLoad *load )
{
  VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;

  if( vips__png_read( png-&gt;filename, load-&gt;real ) )
  	return( -1 );

  return( 0 );
}

static void
vips_foreign_load_png_class_init( VipsForeignLoadPngClass *class )
{
  GObjectClass *gobject_class = G_OBJECT_CLASS( class );
  VipsObjectClass *object_class = (VipsObjectClass *) class;
  VipsForeignClass *foreign_class = (VipsForeignClass *) class;
  VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

  gobject_class-&gt;set_property = vips_object_set_property;
  gobject_class-&gt;get_property = vips_object_get_property;

  object_class-&gt;nickname = "pngload";
  object_class-&gt;description = _( "load png from file" );

  foreign_class-&gt;suffs = vips__png_suffs;

  load_class-&gt;is_a = vips__png_ispng;
  load_class-&gt;get_flags_filename =
  	vips_foreign_load_png_get_flags_filename;
  load_class-&gt;get_flags = vips_foreign_load_png_get_flags;
  load_class-&gt;header = vips_foreign_load_png_header;
  load_class-&gt;load = vips_foreign_load_png_load;

  VIPS_ARG_STRING( class, "filename", 1,
  	_( "Filename" ),
  	_( "Filename to load from" ),
  	VIPS_ARGUMENT_REQUIRED_INPUT,
  	G_STRUCT_OFFSET( VipsForeignLoadPng, filename ),
  	NULL );
}

static void
vips_foreign_load_png_init( VipsForeignLoadPng *png )
{
}
]|</doc>
      <field name="parent_class">
        <type name="ForeignClass" c:type="VipsForeignClass"/>
      </field>
      <field name="is_a">
        <callback name="is_a">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_a_buffer">
        <callback name="is_a_buffer">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gsize" c:type="size_t"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags_filename">
        <callback name="get_flags_filename">
          <return-value transfer-ownership="none">
            <type name="ForeignFlags" c:type="VipsForeignFlags"/>
          </return-value>
          <parameters>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <return-value transfer-ownership="none">
            <type name="ForeignFlags" c:type="VipsForeignFlags"/>
          </return-value>
          <parameters>
            <parameter name="load" transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header">
        <callback name="header">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="load" transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load">
        <callback name="load">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="load" transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="ForeignPngFilter"
              glib:type-name="VipsForeignPngFilter"
              glib:get-type="vips_foreign_png_filter_get_type"
              c:type="VipsForeignPngFilter">
      <doc xml:space="preserve">http://www.w3.org/TR/PNG-Filters.html
The values mirror those of png.h in libpng.</doc>
      <member name="none"
              value="8"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no filtering</doc>
      </member>
      <member name="sub"
              value="16"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_SUB"
              glib:nick="sub">
        <doc xml:space="preserve">difference to the left</doc>
      </member>
      <member name="up"
              value="32"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_UP"
              glib:nick="up">
        <doc xml:space="preserve">difference up</doc>
      </member>
      <member name="avg"
              value="64"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_AVG"
              glib:nick="avg">
        <doc xml:space="preserve">average of left and up</doc>
      </member>
      <member name="paeth"
              value="128"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_PAETH"
              glib:nick="paeth">
        <doc xml:space="preserve">pick best neighbor predictor automatically</doc>
      </member>
      <member name="all"
              value="234"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_ALL"
              glib:nick="all">
        <doc xml:space="preserve">adaptive</doc>
      </member>
    </bitfield>
    <class name="ForeignSave"
           c:symbol-prefix="foreign_save"
           c:type="VipsForeignSave"
           parent="Foreign"
           abstract="1"
           glib:type-name="VipsForeignSave"
           glib:get-type="vips_foreign_save_get_type"
           glib:type-struct="ForeignSaveClass">
      <property name="background" writable="1" transfer-ownership="none">
        <type name="ArrayDouble"/>
      </property>
      <property name="in" writable="1" transfer-ownership="none">
        <type name="Image"/>
      </property>
      <property name="strip" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_object">
        <type name="Foreign" c:type="VipsForeign"/>
      </field>
      <field name="strip">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="background">
        <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
      </field>
      <field name="in">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="ready">
        <type name="Image" c:type="VipsImage*"/>
      </field>
    </class>
    <record name="ForeignSaveClass"
            c:type="VipsForeignSaveClass"
            glib:is-gtype-struct-for="ForeignSave">
      <doc xml:space="preserve">Call your saver in the class' @build() method after chaining up. The
prepared image should be ready for you to save in @ready.

As a complete example, here's the code for the CSV saver, minus the calls
to the actual save routines.

|[
typedef struct _VipsForeignSaveCsv {
  VipsForeignSave parent_object;

  char *filename;
  const char *separator;
} VipsForeignSaveCsv;

typedef VipsForeignSaveClass VipsForeignSaveCsvClass;

G_DEFINE_TYPE( VipsForeignSaveCsv, vips_foreign_save_csv,
  VIPS_TYPE_FOREIGN_SAVE );

static int
vips_foreign_save_csv_build( VipsObject *object )
{
  VipsForeignSave *save = (VipsForeignSave *) object;
  VipsForeignSaveCsv *csv = (VipsForeignSaveCsv *) object;

  if( VIPS_OBJECT_CLASS( vips_foreign_save_csv_parent_class )-&gt;
  	build( object ) )
  	return( -1 );

  if( vips__csv_write( save-&gt;ready, csv-&gt;filename, csv-&gt;separator ) )
  	return( -1 );

  return( 0 );
}

static void
vips_foreign_save_csv_class_init( VipsForeignSaveCsvClass *class )
{
  GObjectClass *gobject_class = G_OBJECT_CLASS( class );
  VipsObjectClass *object_class = (VipsObjectClass *) class;
  VipsForeignClass *foreign_class = (VipsForeignClass *) class;
  VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;

  gobject_class-&gt;set_property = vips_object_set_property;
  gobject_class-&gt;get_property = vips_object_get_property;

  object_class-&gt;nickname = "csvsave";
  object_class-&gt;description = _( "save image to csv file" );
  object_class-&gt;build = vips_foreign_save_csv_build;

  foreign_class-&gt;suffs = vips__foreign_csv_suffs;

  save_class-&gt;saveable = VIPS_SAVEABLE_MONO;
  // no need to define -&gt;format_table, we don't want the input
  // cast for us

  VIPS_ARG_STRING( class, "filename", 1,
  	_( "Filename" ),
  	_( "Filename to save to" ),
  	VIPS_ARGUMENT_REQUIRED_INPUT,
  	G_STRUCT_OFFSET( VipsForeignSaveCsv, filename ),
  	NULL );

  VIPS_ARG_STRING( class, "separator", 13,
  	_( "Separator" ),
  	_( "Separator characters" ),
  	VIPS_ARGUMENT_OPTIONAL_INPUT,
  	G_STRUCT_OFFSET( VipsForeignSaveCsv, separator ),
  	"\t" );
}

static void
vips_foreign_save_csv_init( VipsForeignSaveCsv *csv )
{
  csv-&gt;separator = g_strdup( "\t" );
}
]|</doc>
      <field name="parent_class">
        <type name="ForeignClass" c:type="VipsForeignClass"/>
      </field>
      <field name="saveable">
        <type name="Saveable" c:type="VipsSaveable"/>
      </field>
      <field name="format_table">
        <type name="BandFormat" c:type="VipsBandFormat*"/>
      </field>
      <field name="coding">
        <array zero-terminated="0" c:type="gboolean">
          <type name="gboolean" c:type="gboolean"/>
        </array>
      </field>
    </record>
    <enumeration name="ForeignTiffCompression"
                 glib:type-name="VipsForeignTiffCompression"
                 glib:get-type="vips_foreign_tiff_compression_get_type"
                 c:type="VipsForeignTiffCompression">
      <doc xml:space="preserve">The compression types supported by the tiff writer.

Use @Q to set the jpeg compression level, default 75.

Use @prediction to set the lzw or deflate prediction, default none.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no compression</doc>
      </member>
      <member name="jpeg"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_JPEG"
              glib:nick="jpeg">
        <doc xml:space="preserve">jpeg compression</doc>
      </member>
      <member name="deflate"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE"
              glib:nick="deflate">
        <doc xml:space="preserve">deflate (zip) compression</doc>
      </member>
      <member name="packbits"
              value="3"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS"
              glib:nick="packbits">
        <doc xml:space="preserve">packbits compression</doc>
      </member>
      <member name="ccittfax4"
              value="4"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4"
              glib:nick="ccittfax4">
        <doc xml:space="preserve">fax4 compression</doc>
      </member>
      <member name="lzw"
              value="5"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_LZW"
              glib:nick="lzw">
        <doc xml:space="preserve">LZW compression</doc>
      </member>
      <member name="last"
              value="6"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="ForeignTiffPredictor"
                 glib:type-name="VipsForeignTiffPredictor"
                 glib:get-type="vips_foreign_tiff_predictor_get_type"
                 c:type="VipsForeignTiffPredictor">
      <doc xml:space="preserve">The predictor can help deflate and lzw compression. The values are fixed by
the tiff library.</doc>
      <member name="none"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no prediction</doc>
      </member>
      <member name="horizontal"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL"
              glib:nick="horizontal">
        <doc xml:space="preserve">horizontal differencing</doc>
      </member>
      <member name="float"
              value="3"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT"
              glib:nick="float">
        <doc xml:space="preserve">float predictor</doc>
      </member>
      <member name="last"
              value="4"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="ForeignTiffResunit"
                 glib:type-name="VipsForeignTiffResunit"
                 glib:get-type="vips_foreign_tiff_resunit_get_type"
                 c:type="VipsForeignTiffResunit">
      <doc xml:space="preserve">Use inches or centimeters as the resolution unit for a tiff file.</doc>
      <member name="cm"
              value="0"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_CM"
              glib:nick="cm">
        <doc xml:space="preserve">use centimeters</doc>
      </member>
      <member name="inch"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_INCH"
              glib:nick="inch">
        <doc xml:space="preserve">use inches</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <callback name="GenerateFn" c:type="VipsGenerateFn">
      <doc xml:space="preserve">Fill @out-&gt;valid with pixels. @seq contains per-thread state, such as the
input regions. Set @stop to %TRUE to stop processing.

See also: vips_image_generate(), vips_stop_many().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">#VipsRegion to fill</doc>
          <type name="gpointer" c:type="_VipsRegion*"/>
        </parameter>
        <parameter name="seq"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">sequence value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="stop" transfer-ownership="none">
          <doc xml:space="preserve">set this to stop processing</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </callback>
    <function name="HSV2sRGB" c:identifier="vips_HSV2sRGB" introspectable="0">
      <doc xml:space="preserve">Convert HSV to sRGB.

HSV is a crude polar coordinate system for RGB images. It is provided for
compatibility with other image processing systems. See vips_Lab2LCh() for a
much better colour space.

See also: vips_sRGB2HSV().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <constant name="INTERPOLATE_SCALE"
              value="1"
              c:type="VIPS_INTERPOLATE_SCALE">
      <doc xml:space="preserve">#VIPS_INTERPOLATE_SHIFT as a multiplicative constant.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="INTERPOLATE_SHIFT"
              value="12"
              c:type="VIPS_INTERPOLATE_SHIFT">
      <doc xml:space="preserve">Many of the vips interpolators use fixed-point arithmetic for value
calcualtion. This is how many bits of precision they use.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Image"
           c:symbol-prefix="image"
           c:type="VipsImage"
           parent="Object"
           glib:type-name="VipsImage"
           glib:get-type="vips_image_get_type"
           glib:type-struct="ImageClass">
      <doc xml:space="preserve">An image. These can represent an image on disc, a memory buffer, an image
in the process of being written to disc or a partially evaluated image
in memory.</doc>
      <constructor name="new" c:identifier="vips_image_new">
        <doc xml:space="preserve">vips_image_new() creates a new, empty #VipsImage.
If you write to one of these images, vips will just attach some callbacks,
no pixels will be generated.

Write pixels to an image with vips_image_generate() or
vips_image_write_line(). Write a whole image to another image with
vips_image_write().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_buffer"
                   c:identifier="vips_image_new_from_buffer"
                   introspectable="0">
        <doc xml:space="preserve">Loads an image from the formatted area of memory @buf, @len using the
loader recommended by vips_foreign_find_load_buffer(). Only TIFF, PNG and
JPEG formats are supported. To load an unformatted area of memory, use
vips_image_new_from_memory().

VIPS does not take
responsibility for the area of memory, it's up to you to make sure it's
freed when the image is closed. See for example #VipsObject::close.

Load options may be given in @option_string as "[name=value,...]" or given as
a NULL-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.

See also: vips_image_write_to_buffer().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">image data</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of memory buffer</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="option_string" transfer-ownership="none">
            <doc xml:space="preserve">set of extra options as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="vips_image_new_from_file"
                   introspectable="0">
        <doc xml:space="preserve">Optional arguments:

vips_image_new_from_file() opens @name for reading. It can load files
in many image formats, including VIPS, TIFF, PNG, JPEG, FITS, Matlab,
OpenEXR, CSV, WebP, Radiance, RAW, PPM and others.

Load options may be appended to @filename as "[name=value,...]" or given as
a NULL-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.
Many loaders add extra options, see vips_jpegload(), for example.

vips_image_new_from_file() always returns immediately with the header
fields filled in. No pixels are actually read until you first access them.

@access lets you set a #VipsAccess hint giving the expected access pattern
for this file.
#VIPS_ACCESS_RANDOM means you can fetch pixels randomly from the image.
This is the default mode. #VIPS_ACCESS_SEQUENTIAL means you will read the
whole image exactly once, top-to-bottom. In this mode, vips can avoid
converting the whole image in one go, for a large memory saving. You are
allowed to make small non-local references, so area operations like
convolution will work. #VIPS_ACCESS_SEQUENTIAL_UNBUFFERED does not allow
non-local references, so will only work for very strict top-to-bottom
operations, but does have very low memory needs.

In #VIPS_ACCESS_RANDOM mode, small images are decompressed to memory and
then processed from there. Large images are decompressed to temporary
random-access files on disc and then processed from there. Set @disc to
%TRUE to force loading via disc. See vips_image_new_temp_file() for an
explanation of how VIPS selects a location for the temporary file.

The disc threshold can be set with the "--vips-disc-threshold"
command-line argument, or the VIPS_DISC_THRESHOLD environment variable.
The value is a simple integer, but can take a unit postfix of "k",
"m" or "g" to indicate kilobytes, megabytes or gigabytes.
The default threshold is 100 MB.

For example:

|[
VipsImage *image = vips_image_new_from_file ("fred.tif",
	"page", 12,
	NULL);
]|

Will open "fred.tif", reading page 12.

|[
VipsImage *image = vips_image_new_from_file ("fred.jpg[shrink=2]",
	NULL);
]|

Will open "fred.jpg", downsampling by a factor of two.

Use vips_foreign_find_load() or vips_foreign_is_a() to see what format a
file is in and therefore what options are available. If you need more
control over the loading process, you can call loaders directly, see
vips_jpegload(), for example.

See also: vips_foreign_find_load(), vips_foreign_is_a(),
vips_image_write_to_file().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">file to open</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file_RW"
                   c:identifier="vips_image_new_from_file_RW">
        <doc xml:space="preserve">Opens the named file for simultaneous reading and writing. This will only
work for VIPS files in a format native to your machine. It is only for
paintbox-type applications.

See also: vips_draw_circle().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to open</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file_raw"
                   c:identifier="vips_image_new_from_file_raw">
        <doc xml:space="preserve">This function maps the named file and returns a #VipsImage you can use to
read it.

It returns an 8-bit image with @bands bands. If the image is not 8-bit, use
vips_copy() to transform the descriptor after loading it.

See also: vips_copy(), vips_rawload(), vips_image_new_from_file().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to open</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">bytes to skip at start of file</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_memory"
                   c:identifier="vips_image_new_from_memory">
        <doc xml:space="preserve">This function wraps a #VipsImage around a memory area. The memory area
must be a simple array, for example RGBRGBRGB, left-to-right,
top-to-bottom. Use vips_image_new_from_buffer() to load an area of memory
containing an image in a format.

VIPS does not take
responsibility for the area of memory, it's up to you to make sure it's
freed when the image is closed. See for example #VipsObject::close.

Because VIPS is "borrowing" @data from the caller, this function is
extremely dangerous. Unless you are very careful, you will get crashes or
memory corruption. Use vips_image_new_from_memory_copy() instead if you are
at all unsure.

Use vips_copy() to set other image properties.

See also: vips_image_new(), vips_image_write_to_memory(),
vips_image_new_from_memory_copy().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">start of memory area</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">length of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">image format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_memory_copy"
                   c:identifier="vips_image_new_from_memory_copy">
        <doc xml:space="preserve">Like vips_image_new_from_memory(), but VIPS will make a copy of the memory
area. This
means more memory use and an extra copy operation, but is much simpler and
safer.

See also: vips_image_new_from_memory().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">start of memory area</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">length of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">image format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_matrix" c:identifier="vips_image_new_matrix">
        <doc xml:space="preserve">This convenience function makes an image which is a matrix: a one-band
#VIPS_FORMAT_DOUBLE image held in memory.

Use VIPS_IMAGE_ADDR(), or VIPS_MATRIX() to address pixels in the image.

Use vips_image_set_double() to set "scale" and "offset", if required.

See also: vips_image_new_matrixv()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_matrix_from_array"
                   c:identifier="vips_image_new_matrix_from_array">
        <doc xml:space="preserve">A binding-friendly version of vips_image_new_matrixv().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">array of elements</doc>
            <array length="3" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">number of elements</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_matrixv"
                   c:identifier="vips_image_new_matrixv"
                   introspectable="0">
        <doc xml:space="preserve">As vips_image_new_matrix(), but initialise the matrix from the argument
list. After @height should be @width * @height double constants which are
used to set the matrix elements.

See also: vips_image_new_matrix()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">matrix coefficients</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_memory" c:identifier="vips_image_new_memory">
        <doc xml:space="preserve">vips_image_new_memory() creates a new #VipsImage which, when written to, will
create a memory image.

See also: vips_image_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </constructor>
      <constructor name="new_temp_file"
                   c:identifier="vips_image_new_temp_file">
        <doc xml:space="preserve">Make a #VipsImage which, when written to, will create a temporary file on
disc. The file will be automatically deleted when the image is destroyed.
@format is something like "&amp;percnt;s.v" for a vips file.

The file is created in the temporary directory. This is set with the
environment variable TMPDIR. If this is not set, then on Unix systems, vips
will default to /tmp. On Windows, vips uses GetTempPath() to find the
temporary directory.

vips uses g_mkstemp() to make the temporary filename. They generally look
something like "vips-12-EJKJFGH.v".

See also: vips_image_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format of file</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="matrix_from_array"
                c:identifier="vips_image_matrix_from_array">
        <doc xml:space="preserve">A renamed vips_image_new_matrix_from_array(). Some gobject bindings do not
like more than one _new method.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">array of elements</doc>
            <array length="3" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">number of elements</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="memory" c:identifier="vips_image_memory">
        <doc xml:space="preserve">A renamed vips_image_new_memory() ... Some gobject binding systems do not
like more than one _new() method.

See also: vips_image_new_memory().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </function>
      <virtual-method name="eval">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="Progress" c:type="VipsProgress*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="invalidate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="minimise">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="posteval">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="Progress" c:type="VipsProgress*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="preeval">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="Progress" c:type="VipsProgress*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="written">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="copy_memory"
              c:identifier="vips_image_copy_memory"
              introspectable="0">
        <doc xml:space="preserve">Allocate a memory buffer and copy @image to it. This is a thread-safe
equivalent of vips_image_wio_input(), useful if @image is small and from an
unknown source.

If @image is already in memory (perhaps a mmaped file on disc),
vips_image_copy_memory() will just ref @image and return that.

If you are sure that @image is not shared with another thread (perhaps you
have made it yourself), use vips_image_wio_input() instead.

See also: vips_image_wio_input().</doc>
        <return-value>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to copy to a memory buffer</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="decode" c:identifier="vips_image_decode">
        <doc xml:space="preserve">A convenience function to unpack to a format that we can compute with.
@out.coding is always #VIPS_CODING_NONE.

This unpacks LABQ to plain LAB. Use vips_LabQ2LabS() for a bit more speed
if you need it.

See also: vips_image_encode(), vips_LabQ2Lab(), vips_rad2float().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">image to decode</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve">write to this image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_predict" c:identifier="vips_image_decode_predict">
        <doc xml:space="preserve">We often need to know what an image will decode to without actually
decoding it, for example, in arg checking.

See also: vips_image_decode().</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">image to decode</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve">predict bands here</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">predict format here</doc>
            <type name="BandFormat" c:type="VipsBandFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encode" c:identifier="vips_image_encode">
        <doc xml:space="preserve">A convenience function to pack to a coding. The inverse of
vips_image_decode().

See also: vips_image_decode().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">image to encode</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve">write to this image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="coding" transfer-ownership="none">
            <doc xml:space="preserve">coding to apply</doc>
            <type name="Coding" c:type="VipsCoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="vips_image_get">
        <doc xml:space="preserve">Fill @value_copy with a copy of the header field. @value_copy must be zeroed
but uninitialised.

This will return -1 and add a message to the error buffer if the field
does not exist. Use vips_image_get_typeof() to test for the
existence of a field first if you are not certain it will be there.

For example, to read a double from an image (though of course you would use
vips_image_get_double() in practice):

|[
GValue value = { 0 };
double d;

if (vips_image_get (image, field, &amp;amp;value))
  return -1;

if (G_VALUE_TYPE (&amp;amp;value) != G_TYPE_DOUBLE) {
  vips_error( "mydomain",
    _("field \"%s\" is of type %s, not double"),
    field,
    g_type_name (G_VALUE_TYPE (&amp;amp;value)));
  g_value_unset (&amp;amp;value);
  return -1;
}

d = g_value_get_double (&amp;amp;value);
g_value_unset (&amp;amp;value);
]|

See also: vips_image_get_typeof(), vips_image_get_double().</doc>
        <return-value transfer-ownership="none" skip="1">
          <doc xml:space="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get the field from from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the name to give the metadata</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value_copy"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve">the %GValue is copied into this</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_area" c:identifier="vips_image_get_area">
        <doc xml:space="preserve">Gets @data from @image under the name @field. A convenience
function over vips_image_get(). Use vips_image_get_typeof() to test for
the existance of a piece of metadata.

See also: vips_image_set_area(), vips_image_get(),
vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get the metadata from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">return metadata value</doc>
            <type name="gpointer" c:type="void**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_as_string" c:identifier="vips_image_get_as_string">
        <doc xml:space="preserve">Gets @out from @im under the name @field.
This function will read any field, returning it as a printable string.
You need to free the string with g_free() when you are done with it.

See also: vips_image_get(), vips_image_get_typeof().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="full">
            <doc xml:space="preserve">return field value as string</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bands" c:identifier="vips_image_get_bands">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bands (channels) in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blob" c:identifier="vips_image_get_blob">
        <doc xml:space="preserve">Gets @blob from @image under the name @field, optionally return its length in
@length. A convenience
function over vips_image_get(). Use vips_image_get_typeof() to test for the
existance
of a piece of metadata.

See also: vips_image_get(), vips_image_get_typeof(), vips_blob_get(),</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get the metadata from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to area of memory</doc>
            <type name="gpointer" c:type="void**"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">return the blob length here, optionally</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_coding" c:identifier="vips_image_get_coding">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the image coding</doc>
          <type name="Coding" c:type="VipsCoding"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="vips_image_get_data">
        <doc xml:space="preserve">Return a pointer to the image's pixel data, if possible. This can involve
allocating large amounts of memory and performing a long computation. Image
pixels are laid out in band-packed rows.

Since this function modifies @image, it is not threadsafe. Only call it on
images which you are sure have not been shared with another thread.

See also: vips_image_wio_input(), vips_image_copy_memory().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a pointer to pixel data, if possible.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get data for</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="vips_image_get_double">
        <doc xml:space="preserve">Gets @out from @im under the name @field.
This function searches for
double-valued fields.

See also: vips_image_get(), vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve">return field value</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_filename" c:identifier="vips_image_get_filename">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the file the image was loaded from.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="vips_image_get_format">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the format of each band element.</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="vips_image_get_height">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of pixels down the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_history" c:identifier="vips_image_get_history">
        <doc xml:space="preserve">This function reads the image history as a C string. The string is owned
by VIPS and must not be freed.

VIPS tracks the history of each image, that is, the sequence of operations
that generated that image. Applications built on VIPS need to call
vips_image_history_printf() for each action they perform, setting the
command-line equivalent for the action.

See also: vips_image_history_printf().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The history of @image as a C string. Do not free!</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">get history from here</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="vips_image_get_int">
        <doc xml:space="preserve">Gets @out from @im under the name @field. This function searches for
int-valued fields.

See also: vips_image_get(), vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve">return field value</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_interpretation"
              c:identifier="vips_image_get_interpretation">
        <doc xml:space="preserve">Return the #VipsInterpretation set in the image header.
Use vips_image_guess_interpretation() if you want a sanity-checked value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #VipsInterpretation from the image header.</doc>
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="vips_image_get_mode">
        <doc xml:space="preserve">Image modes are things like `"t"`, meaning a memory buffer, and `"p"`
meaning a delayed computation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the image mode.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="vips_image_get_offset">
        <doc xml:space="preserve">Matrix images can have an optional `offset` field for use by integer
convolution.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scale" c:identifier="vips_image_get_scale">
        <doc xml:space="preserve">Matrix images can have an optional `scale` field for use by integer
convolution.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scale.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="vips_image_get_string">
        <doc xml:space="preserve">Gets @out from @im under the name @field.
This function searches for string-valued fields.

Do not free @out.

See also: vips_image_get(), vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve">return field value</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_typeof" c:identifier="vips_image_get_typeof">
        <doc xml:space="preserve">Read the %GType for a header field. Returns zero if there is no
field of that name.

See also: vips_image_get().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the %GType of the field, or zero if there is no
field of that name.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to test</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the name to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="vips_image_get_width">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of pixels across the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_xoffset" c:identifier="vips_image_get_xoffset">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the horizontal position of the image origin, in pixels.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_xres" c:identifier="vips_image_get_xres">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the horizontal image resolution in pixels per millimeter.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_yoffset" c:identifier="vips_image_get_yoffset">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the vertical position of the image origin, in pixels.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_yres" c:identifier="vips_image_get_yres">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the vertical image resolution in pixels per millimeter.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_interpretation"
              c:identifier="vips_image_guess_interpretation">
        <doc xml:space="preserve">Return the #VipsInterpretation for an image, guessing a sane value if
the set value looks crazy.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a sensible #VipsInterpretation for the image.</doc>
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to guess for</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="history_args" c:identifier="vips_image_history_args">
        <doc xml:space="preserve">Formats the name/argv as a single string and calls
vips_image_history_printf(). A
convenience function for command-line prorams.

See also: vips_image_get_history().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to attach history line to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">program name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:space="preserve">number of program arguments</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none">
            <doc xml:space="preserve">program arguments</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="history_printf"
              c:identifier="vips_image_history_printf"
              introspectable="0">
        <doc xml:space="preserve">Add a line to the image history. The @format and arguments are expanded, the
date and time is appended prefixed with a hash character, and the whole
string is appended to the image history and terminated with a newline.

For example:

|[
vips_image_history_printf (image, "vips invert %s %s",
  in-&gt;filename, out-&gt;filename);
]|

Might add the string

|[
"vips invert /home/john/fred.v /home/john/jim.v # Fri Apr 3 23:30:35 2009\n"
]|

VIPS operations don't add history lines for you because a single action at
the application level might involve many VIPS operations. History must be
recorded by the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">add history line to this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">printf() format string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments to format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="init_fields" c:identifier="vips_image_init_fields">
        <doc xml:space="preserve">A convenience function to set the header fields after creating an image.
Normally you copy the fields from your input images with
vips_image_pipelinev() and then make
any adjustments you need, but if you are creating an image from scratch,
for example vips_black() or vips_jpegload(), you do need to set all the
fields yourself.

See also: vips_image_pipelinev().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to init</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:space="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:space="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve">image bands</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">band format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
          <parameter name="coding" transfer-ownership="none">
            <doc xml:space="preserve">image coding</doc>
            <type name="Coding" c:type="VipsCoding"/>
          </parameter>
          <parameter name="interpretation" transfer-ownership="none">
            <doc xml:space="preserve">image type</doc>
            <type name="Interpretation" c:type="VipsInterpretation"/>
          </parameter>
          <parameter name="xres" transfer-ownership="none">
            <doc xml:space="preserve">horizontal resolution, pixels per millimetre</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yres" transfer-ownership="none">
            <doc xml:space="preserve">vertical resolution, pixels per millimetre</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="inplace" c:identifier="vips_image_inplace">
        <doc xml:space="preserve">Gets @image ready for an in-place operation, such as vips_draw_circle().
After calling this function you can both read and write the image with
VIPS_IMAGE_ADDR().

Since this function modifies @image, it is not thread-safe. Only call it on
images which you are sure have not been shared with another thread.
All in-place operations are inherently not thread-safe, so you need to take
great care in any case.

See also: vips_draw_circle(), vips_image_wio_input().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on succeess, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to make read-write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate_all" c:identifier="vips_image_invalidate_all">
        <doc xml:space="preserve">Invalidate all pixel caches on @image and any downstream images, that
is, images which depend on this image. Additionally, all operations which
depend upon this image are dropped from the VIPS operation cache.

You should call this function after
destructively modifying an image with something like vips_draw_circle().

The #VipsImage::invalidate signal is emitted for all invalidated images.

See also: vips_region_invalidate().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">#VipsImage to invalidate</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="isMSBfirst" c:identifier="vips_image_isMSBfirst">
        <doc xml:space="preserve">Return %TRUE if @image is in most-significant-
byte first form. This is the byte order used on the SPARC
architecture and others.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="isfile" c:identifier="vips_image_isfile">
        <doc xml:space="preserve">Return %TRUE if @image represents a file on disc in some way.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ispartial" c:identifier="vips_image_ispartial">
        <doc xml:space="preserve">Return %TRUE if @im represents a partial image (a delayed calculation).</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="vips_image_map">
        <doc xml:space="preserve">This function calls @fn for every header field, including every item of
metadata.

Like all _map functions, the user function should return %NULL to continue
iteration, or a non-%NULL pointer to indicate early termination.

See also: vips_image_get_typeof(), vips_image_get().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">%NULL on success, the failing pointer otherwise.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to map over</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="fn" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">function to call for each header field</doc>
            <type name="ImageMapFn" c:type="VipsImageMapFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for function</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="minimise_all" c:identifier="vips_image_minimise_all">
        <doc xml:space="preserve">Minimise memory use on this image and any upstream images, that is, images
which this image depends upon. This function is called automatically at the
end of a computation, but it might be useful to call at other times.

The #VipsImage::minimise signal is emitted for all minimised images.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">#VipsImage to minimise</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pio_input" c:identifier="vips_image_pio_input">
        <doc xml:space="preserve">Check that an image is readable with vips_region_prepare() and friends.
If it isn't, try to transform the image so that vips_region_prepare() can
work.

See also: vips_image_pio_output(), vips_region_prepare().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on succeess, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to check</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pio_output" c:identifier="vips_image_pio_output">
        <doc xml:space="preserve">Check that an image is writeable with vips_image_generate(). If it isn't,
try to transform the image so that vips_image_generate() can work.

See also: vips_image_pio_input().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on succeess, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to check</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="vips_image_remove">
        <doc xml:space="preserve">Find and remove an item of metadata. Return %FALSE if no metadata of that
name was found.

See also: vips_image_set(), vips_image_get_typeof().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if an item of metadata of that name was found and removed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the name to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="vips_image_set">
        <doc xml:space="preserve">Set a piece of metadata on @image. Any old metadata with that name is
destroyed. The %GValue is copied into the image, so you need to unset the
value when you're done with it.

For example, to set an integer on an image (though you would use the
convenience function vips_image_set_int() in practice), you would do:

|[
GValue value = { 0 };

g_value_init (&amp;amp;value, G_TYPE_INT);
g_value_set_int (&amp;amp;value, 42);
vips_image_set (image, field, &amp;amp;value);
g_value_unset (&amp;amp;value);
]|

See also: vips_image_get().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to set the metadata on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the name to give the metadata</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the %GValue to copy into the image</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_area" c:identifier="vips_image_set_area">
        <doc xml:space="preserve">Attaches @data as a metadata item on @image under the name @field. When
VIPS no longer needs the metadata, it will be freed with @free_fn.

See also: vips_image_get_double(), vips_image_set()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">free function for @data</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to area of memory</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blob" c:identifier="vips_image_set_blob">
        <doc xml:space="preserve">Attaches @blob as a metadata item on @image under the name @field. A
convenience
function over vips_image_set() using an vips_blob.

See also: vips_image_get_blob(), vips_image_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">free function for @data</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to area of memory</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delete_on_close"
              c:identifier="vips_image_set_delete_on_close">
        <doc xml:space="preserve">Sets the delete_on_close flag for the image. If this flag is set, when
@image is finalized, the filename held in @image-&gt;filename at the time of
this call is deleted.

This function is clearly extremely dangerous, use with great caution.

See also: vips_image_new_temp_file().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to set</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="delete_on_close" transfer-ownership="none">
            <doc xml:space="preserve">format of file</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="vips_image_set_double">
        <doc xml:space="preserve">Attaches @d as a metadata item on @image under the name @field. A
convenience
function over vips_image_set().

See also: vips_image_get_double(), vips_image_set()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">metadata value</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="vips_image_set_int">
        <doc xml:space="preserve">Attaches @i as a metadata item on @image under the name @field. A
convenience
function over vips_image_set().

See also: vips_image_get_int(), vips_image_set()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">metadata value</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_progress" c:identifier="vips_image_set_progress">
        <doc xml:space="preserve">vips signals evaluation progress via the #VipsImage::preeval,
#VipsImage::eval and #VipsImage::posteval
signals. Progress is signalled on the most-downstream image for which
vips_image_set_progress() was called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to signal progress on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">turn progress reporting on or off</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="vips_image_set_string">
        <doc xml:space="preserve">Attaches @str as a metadata item on @image under the name @field.
A convenience
function over vips_image_set() using an vips_ref_string.

See also: vips_image_get_double(), vips_image_set(), vips_ref_string</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">metadata value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wio_input" c:identifier="vips_image_wio_input">
        <doc xml:space="preserve">Check that an image is readable via the VIPS_IMAGE_ADDR() macro, that is,
that the entire image is in memory and all pixels can be read with
VIPS_IMAGE_ADDR().  If it
isn't, try to transform it so that VIPS_IMAGE_ADDR() can work.

Since this function modifies @image, it is not thread-safe. Only call it on
images which you are sure have not been shared with another thread. If the
image might have been shared, use the less efficient
vips_image_copy_memory() instead.

See also: vips_image_copy_memory(), vips_image_pio_input(), vips_image_inplace(), VIPS_IMAGE_ADDR().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on succeess, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to transform</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="vips_image_write">
        <doc xml:space="preserve">Write @image to @out. Use vips_image_new() and friends to create the
#VipsImage you want to write to.

See also: vips_image_new(), vips_copy(), vips_image_write_to_file().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve">write to this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_line" c:identifier="vips_image_write_line">
        <doc xml:space="preserve">Write a line of pixels to an image. This function must be called repeatedly
with @ypos increasing from 0 to #VipsImage::height .
@linebuffer must be VIPS_IMAGE_SIZEOF_LINE() bytes long.

See also: vips_image_generate().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to write to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ypos" transfer-ownership="none">
            <doc xml:space="preserve">vertical position of scan-line to write</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="linebuffer" transfer-ownership="none">
            <doc xml:space="preserve">scanline of pixels</doc>
            <type name="Pel" c:type="VipsPel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_prepare" c:identifier="vips_image_write_prepare">
        <doc xml:space="preserve">Call this after setting header fields (width, height, and so on) to
allocate resources ready for writing.

Normally this function is called for you by vips_image_generate() or
vips_image_write_line(). You will need to call it yourself if you plan to
write directly to the -&gt;data member of a memory image.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to prepare</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_to_buffer"
              c:identifier="vips_image_write_to_buffer"
              introspectable="0">
        <doc xml:space="preserve">Writes @in to a memory buffer in a format specified by @suffix.

Save options may be appended to @suffix as "[name=value,...]" or given as
a NULL-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.

Currently only TIFF, JPEG and PNG formats are supported.

You can call the various save operations directly if you wish, see
vips_jpegsave_buffer(), for example.

See also: vips_image_write_to_memory(), vips_image_new_from_buffer().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="suffix" transfer-ownership="none">
            <doc xml:space="preserve">format to write</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="full">
            <doc xml:space="preserve">return buffer start here</doc>
            <array length="2" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">return buffer length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_file"
              c:identifier="vips_image_write_to_file"
              introspectable="0">
        <doc xml:space="preserve">Writes @in to @name using the saver recommended by
vips_foreign_find_save().

Save options may be appended to @filename as "[name=value,...]" or given as
a NULL-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.

See also: vips_image_new_from_file().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">write to this file</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_memory" c:identifier="vips_image_write_to_memory">
        <doc xml:space="preserve">Writes @in to memory as a simple, unformatted C-style array.

The caller is responsible for freeing this memory.

See also: vips_image_write_to_buffer().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">return buffer start here</doc>
          <array length="0" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return buffer length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <property name="bands" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="coding" writable="1" transfer-ownership="none">
        <type name="Coding"/>
      </property>
      <property name="demand" writable="1" transfer-ownership="none">
        <type name="DemandStyle"/>
      </property>
      <property name="filename" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="foreign-buffer" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="format" writable="1" transfer-ownership="none">
        <type name="BandFormat"/>
      </property>
      <property name="height" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="interpretation" writable="1" transfer-ownership="none">
        <type name="Interpretation"/>
      </property>
      <property name="kill" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mode" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="sizeof-header" writable="1" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="width" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="xoffset" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="xres" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="yoffset" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="yres" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="Xsize" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Ysize" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Bands" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="BandFmt" readable="0" private="1">
        <type name="BandFormat" c:type="VipsBandFormat"/>
      </field>
      <field name="Coding" readable="0" private="1">
        <type name="Coding" c:type="VipsCoding"/>
      </field>
      <field name="Type" readable="0" private="1">
        <type name="Interpretation" c:type="VipsInterpretation"/>
      </field>
      <field name="Xres" readable="0" private="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="Yres" readable="0" private="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="Xoffset" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Yoffset" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Length" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Compression" readable="0" private="1">
        <type name="gshort" c:type="short"/>
      </field>
      <field name="Level" readable="0" private="1">
        <type name="gshort" c:type="short"/>
      </field>
      <field name="Bbits" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="time" readable="0" private="1">
        <type name="Progress" c:type="VipsProgress*"/>
      </field>
      <field name="Hist" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="filename" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="Pel" c:type="VipsPel*"/>
      </field>
      <field name="kill" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Xres_float" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="Yres_float" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="mode" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="dtype" readable="0" private="1">
        <type name="ImageType" c:type="VipsImageType"/>
      </field>
      <field name="fd" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="baseaddr" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="length" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <field name="magic" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="start_fn" readable="0" private="1">
        <type name="StartFn" c:type="VipsStartFn"/>
      </field>
      <field name="generate_fn" readable="0" private="1">
        <type name="GenerateFn" c:type="VipsGenerateFn"/>
      </field>
      <field name="stop_fn" readable="0" private="1">
        <type name="StopFn" c:type="VipsStopFn"/>
      </field>
      <field name="client1" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="client2" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="sslock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="regions" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="dhint" readable="0" private="1">
        <type name="DemandStyle" c:type="VipsDemandStyle"/>
      </field>
      <field name="meta" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="meta_traverse" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="sizeof_header" readable="0" private="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="windows" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="upstream" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="downstream" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="serial" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="history_list" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="progress_signal">
        <type name="gpointer" c:type="_VipsImage*"/>
      </field>
      <field name="file_length">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="hint_set">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delete_on_close">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delete_on_close_filename">
        <type name="utf8" c:type="char*"/>
      </field>
      <glib:signal name="eval" when="last">
        <doc xml:space="preserve">The ::eval signal is emitted once per work unit (typically a 128 x
128 area of pixels) during image computation.

You can use this signal to update user-interfaces with progress
feedback. Beware of updating too frequently: you will usually
need some throttling mechanism.

Use vips_image_set_progress() to turn on progress reporting for an
image.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">#VipsProgress for this image</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidate" when="last" action="1">
        <doc xml:space="preserve">The ::invalidate signal is emitted when an image or one of it's
upstream data sources has been destructively modified. See
vips_image_invalidate_all().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="minimise" when="last" action="1">
        <doc xml:space="preserve">The ::minimise signal is emitted when an image has been asked to
minimise memory usage. All non-essential caches are dropped.
See
vips_image_minimise_all().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="posteval" when="last">
        <doc xml:space="preserve">The ::posteval signal is emitted once at the end of the computation
of @image. It's a good place to shut down evaluation feedback.

Use vips_image_set_progress() to turn on progress reporting for an
image.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">#VipsProgress for this image</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="preeval" when="last">
        <doc xml:space="preserve">The ::preeval signal is emitted once before computation of @image
starts. It's a good place to set up evaluation feedback.

Use vips_image_set_progress() to turn on progress reporting for an
image.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">#VipsProgress for this image</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="written" when="last" action="1">
        <doc xml:space="preserve">The ::written signal is emitted just after an image has been
written to. It is
used by vips to implement things like write to foreign file
formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">set to non-zero to indicate error</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ImageClass"
            c:type="VipsImageClass"
            glib:is-gtype-struct-for="Image">
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="preeval">
        <callback name="preeval">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type name="Progress" c:type="VipsProgress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eval">
        <callback name="eval">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type name="Progress" c:type="VipsProgress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="posteval">
        <callback name="posteval">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type name="Progress" c:type="VipsProgress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="written">
        <callback name="written">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="gint" c:type="int*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="invalidate">
        <callback name="invalidate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="minimise">
        <callback name="minimise">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="ImageMapFn" c:type="VipsImageMapFn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="field" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ImageType"
                 glib:type-name="VipsImageType"
                 glib:get-type="vips_image_type_get_type"
                 c:type="VipsImageType">
      <member name="error"
              value="-1"
              c:identifier="VIPS_IMAGE_ERROR"
              glib:nick="error">
      </member>
      <member name="none"
              value="0"
              c:identifier="VIPS_IMAGE_NONE"
              glib:nick="none">
      </member>
      <member name="setbuf"
              value="1"
              c:identifier="VIPS_IMAGE_SETBUF"
              glib:nick="setbuf">
      </member>
      <member name="setbuf_foreign"
              value="2"
              c:identifier="VIPS_IMAGE_SETBUF_FOREIGN"
              glib:nick="setbuf-foreign">
      </member>
      <member name="openin"
              value="3"
              c:identifier="VIPS_IMAGE_OPENIN"
              glib:nick="openin">
      </member>
      <member name="mmapin"
              value="4"
              c:identifier="VIPS_IMAGE_MMAPIN"
              glib:nick="mmapin">
      </member>
      <member name="mmapinrw"
              value="5"
              c:identifier="VIPS_IMAGE_MMAPINRW"
              glib:nick="mmapinrw">
      </member>
      <member name="openout"
              value="6"
              c:identifier="VIPS_IMAGE_OPENOUT"
              glib:nick="openout">
      </member>
      <member name="partial"
              value="7"
              c:identifier="VIPS_IMAGE_PARTIAL"
              glib:nick="partial">
      </member>
    </enumeration>
    <enumeration name="Intent"
                 glib:type-name="VipsIntent"
                 glib:get-type="vips_intent_get_type"
                 c:type="VipsIntent">
      <doc xml:space="preserve">The rendering intent. #VIPS_INTENT_ABSOLUTE is best for
scientific work, #VIPS_INTENT_RELATIVE is usually best for
accurate communication with other imaging libraries.</doc>
      <member name="perceptual"
              value="0"
              c:identifier="VIPS_INTENT_PERCEPTUAL"
              glib:nick="perceptual">
        <doc xml:space="preserve">perceptual rendering intent</doc>
      </member>
      <member name="relative"
              value="1"
              c:identifier="VIPS_INTENT_RELATIVE"
              glib:nick="relative">
        <doc xml:space="preserve">relative colorimetric rendering intent</doc>
      </member>
      <member name="saturation"
              value="2"
              c:identifier="VIPS_INTENT_SATURATION"
              glib:nick="saturation">
        <doc xml:space="preserve">saturation rendering intent</doc>
      </member>
      <member name="absolute"
              value="3"
              c:identifier="VIPS_INTENT_ABSOLUTE"
              glib:nick="absolute">
        <doc xml:space="preserve">absolute colorimetric rendering intent</doc>
      </member>
      <member name="last"
              value="4"
              c:identifier="VIPS_INTENT_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <class name="Interpolate"
           c:symbol-prefix="interpolate"
           c:type="VipsInterpolate"
           parent="Object"
           abstract="1"
           glib:type-name="VipsInterpolate"
           glib:get-type="vips_interpolate_get_type"
           glib:type-struct="InterpolateClass">
      <constructor name="new" c:identifier="vips_interpolate_new">
        <doc xml:space="preserve">Look up an interpolator from a nickname and make one. You need to free the
result with g_object_unref() when you're done with it.

See also: vips_type_find().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an interpolator, or %NULL on error.</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:space="preserve">nickname for interpolator</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="bilinear_static"
                c:identifier="vips_interpolate_bilinear_static">
        <doc xml:space="preserve">A convenience function that returns a bilinear interpolator you
don't need to free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a bilinear interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
      </function>
      <function name="nearest_static"
                c:identifier="vips_interpolate_nearest_static">
        <doc xml:space="preserve">A convenience function that returns a nearest-neighbour interpolator you
don't need to free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a nearest-neighbour interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
      </function>
      <virtual-method name="get_window_offset" invoker="get_window_offset">
        <doc xml:space="preserve">Look up an interpolators desired window offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interpolators required window offset</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_window_size" invoker="get_window_size">
        <doc xml:space="preserve">Look up an interpolators desired window size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interpolators required window size</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="interpolate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve">the interpolator</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">write the interpolated pixel here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">read source pixels from here</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name=""
              c:identifier="vips_interpolate"
              moved-to="interpolate"
              introspectable="0">
        <doc xml:space="preserve">Look up the @interpolate method in the class and call it. Use
vips_interpolate_get_method() to get a direct pointer to the function and
avoid the lookup overhead.

You need to set @in and @out up correctly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">write result here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">read source data from here</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_method"
              c:identifier="vips_interpolate_get_method"
              introspectable="0">
        <doc xml:space="preserve">Look up the @interpolate method in the class and return it. Use this
instead of vips_interpolate() to cache method dispatch.</doc>
        <return-value>
          <doc xml:space="preserve">a pointer to the interpolation function</doc>
          <type name="InterpolateMethod" c:type="VipsInterpolateMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window_offset"
              c:identifier="vips_interpolate_get_window_offset">
        <doc xml:space="preserve">Look up an interpolators desired window offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interpolators required window offset</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window_size"
              c:identifier="vips_interpolate_get_window_size">
        <doc xml:space="preserve">Look up an interpolators desired window size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interpolators required window size</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
    </class>
    <record name="InterpolateClass"
            c:type="VipsInterpolateClass"
            glib:is-gtype-struct-for="Interpolate">
      <doc xml:space="preserve">The abstract base class for the various VIPS interpolation functions.
Use "vips --list classes" to see all the interpolators available.

An interpolator consists of a function to perform the interpolation, plus
some extra data fields which tell vips how to call the function and what
data it needs.

@window_size is the size of the window that the interpolator needs. For
example, a bicubic interpolator needs to see a window of 4x4 pixels to be
able to interpolate a value.

You can either have a function in @get_window_size which returns the window
that a specific interpolator needs, or you can leave @get_window_size %NULL
and set a constant value in @window_size.

@window_offset is how much to offset the window up and left of (x, y). For
example, a bicubic interpolator will want a @window_offset of 1.

You can either have a function in @get_window_offset which returns the
offset that a specific interpolator needs, or you can leave
@get_window_offset %NULL and set a constant value in @window_offset.

You also need to set @nickname and @description in #VipsObject.

See also: #VipsInterpolateMethod, #VipsObject,
vips_interpolate_bilinear_static().</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="interpolate">
        <doc xml:space="preserve">the interpolation method</doc>
        <type name="InterpolateMethod" c:type="VipsInterpolateMethod"/>
      </field>
      <field name="get_window_size">
        <callback name="get_window_size">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the interpolators required window size</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="interpolate" transfer-ownership="none">
              <doc xml:space="preserve">interpolator to use</doc>
              <type name="Interpolate" c:type="VipsInterpolate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="window_size">
        <doc xml:space="preserve">or just set this for a constant window size</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="get_window_offset">
        <callback name="get_window_offset">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the interpolators required window offset</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="interpolate" transfer-ownership="none">
              <doc xml:space="preserve">interpolator to use</doc>
              <type name="Interpolate" c:type="VipsInterpolate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="window_offset">
        <doc xml:space="preserve">or just set this for a constant window offset</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <callback name="InterpolateMethod" c:type="VipsInterpolateMethod">
      <doc xml:space="preserve">An interpolation function. It should read source pixels from @in with
VIPS_REGION_ADDR(), it can look left and up from (x, y) by @window_offset
pixels and it can access pixels in a window of size @window_size.

The interpolated value should be written to the pixel pointed to by @out.

See also: #VipsInterpolateClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interpolate" transfer-ownership="none">
          <doc xml:space="preserve">the interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </parameter>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">write the interpolated pixel here</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">read source pixels from here</doc>
          <type name="Region" c:type="VipsRegion*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Interpretation"
                 glib:type-name="VipsInterpretation"
                 glib:get-type="vips_interpretation_get_type"
                 c:type="VipsInterpretation">
      <doc xml:space="preserve">How the values in an image should be interpreted. For example, a
three-band float image of type #VIPS_INTERPRETATION_LAB should have its
pixels interpreted as coordinates in CIE Lab space.

These values are set by operations as hints to user-interfaces built on top
of VIPS to help them show images to the user in a meaningful way.
Operations do not use these values to decide their action.

The gaps in numbering are historical and must be maintained. Allocate
new numbers from the end.</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_INTERPRETATION_ERROR"
              glib:nick="error">
      </member>
      <member name="multiband"
              value="0"
              c:identifier="VIPS_INTERPRETATION_MULTIBAND"
              glib:nick="multiband">
        <doc xml:space="preserve">generic many-band image</doc>
      </member>
      <member name="b_w"
              value="1"
              c:identifier="VIPS_INTERPRETATION_B_W"
              glib:nick="b-w">
        <doc xml:space="preserve">some kind of single-band image</doc>
      </member>
      <member name="histogram"
              value="10"
              c:identifier="VIPS_INTERPRETATION_HISTOGRAM"
              glib:nick="histogram">
        <doc xml:space="preserve">a 1D image, eg. histogram or lookup table</doc>
      </member>
      <member name="xyz"
              value="12"
              c:identifier="VIPS_INTERPRETATION_XYZ"
              glib:nick="xyz">
        <doc xml:space="preserve">the first three bands are CIE XYZ</doc>
      </member>
      <member name="lab"
              value="13"
              c:identifier="VIPS_INTERPRETATION_LAB"
              glib:nick="lab">
        <doc xml:space="preserve">pixels are in CIE Lab space</doc>
      </member>
      <member name="cmyk"
              value="15"
              c:identifier="VIPS_INTERPRETATION_CMYK"
              glib:nick="cmyk">
        <doc xml:space="preserve">the first four bands are in CMYK space</doc>
      </member>
      <member name="labq"
              value="16"
              c:identifier="VIPS_INTERPRETATION_LABQ"
              glib:nick="labq">
        <doc xml:space="preserve">implies #VIPS_CODING_LABQ</doc>
      </member>
      <member name="rgb"
              value="17"
              c:identifier="VIPS_INTERPRETATION_RGB"
              glib:nick="rgb">
        <doc xml:space="preserve">generic RGB space</doc>
      </member>
      <member name="cmc"
              value="18"
              c:identifier="VIPS_INTERPRETATION_CMC"
              glib:nick="cmc">
        <doc xml:space="preserve">a uniform colourspace based on CMC(1:1)</doc>
      </member>
      <member name="lch"
              value="19"
              c:identifier="VIPS_INTERPRETATION_LCH"
              glib:nick="lch">
        <doc xml:space="preserve">pixels are in CIE LCh space</doc>
      </member>
      <member name="labs"
              value="21"
              c:identifier="VIPS_INTERPRETATION_LABS"
              glib:nick="labs">
        <doc xml:space="preserve">CIE LAB coded as three signed 16-bit values</doc>
      </member>
      <member name="srgb"
              value="22"
              c:identifier="VIPS_INTERPRETATION_sRGB"
              glib:nick="srgb">
        <doc xml:space="preserve">pixels are sRGB</doc>
      </member>
      <member name="yxy"
              value="23"
              c:identifier="VIPS_INTERPRETATION_YXY"
              glib:nick="yxy">
        <doc xml:space="preserve">pixels are CIE Yxy</doc>
      </member>
      <member name="fourier"
              value="24"
              c:identifier="VIPS_INTERPRETATION_FOURIER"
              glib:nick="fourier">
        <doc xml:space="preserve">image is in fourier space</doc>
      </member>
      <member name="rgb16"
              value="25"
              c:identifier="VIPS_INTERPRETATION_RGB16"
              glib:nick="rgb16">
        <doc xml:space="preserve">generic 16-bit RGB</doc>
      </member>
      <member name="grey16"
              value="26"
              c:identifier="VIPS_INTERPRETATION_GREY16"
              glib:nick="grey16">
        <doc xml:space="preserve">generic 16-bit mono</doc>
      </member>
      <member name="matrix"
              value="27"
              c:identifier="VIPS_INTERPRETATION_MATRIX"
              glib:nick="matrix">
        <doc xml:space="preserve">a matrix</doc>
      </member>
      <member name="scrgb"
              value="28"
              c:identifier="VIPS_INTERPRETATION_scRGB"
              glib:nick="scrgb">
        <doc xml:space="preserve">pixels are scRGB</doc>
      </member>
      <member name="hsv"
              value="29"
              c:identifier="VIPS_INTERPRETATION_HSV"
              glib:nick="hsv">
        <doc xml:space="preserve">pixels are HSV</doc>
      </member>
      <member name="last"
              value="30"
              c:identifier="VIPS_INTERPRETATION_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <function name="LCh2CMC" c:identifier="vips_LCh2CMC" introspectable="0">
      <doc xml:space="preserve">Turn LCh to CMC.

The CMC colourspace is described in "Uniform Colour Space Based on the
CMC(l:c) Colour-difference Formula", M R Luo and B Rigg, Journal of the
Society of Dyers and Colourists, vol 102, 1986. Distances in this
colourspace approximate, within 10% or so, differences in the CMC(l:c)
colour difference formula.

This operation generates CMC(1:1). For CMC(2:1), halve Lucs and double
Cucs.

See also: vips_CMC2LCh().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="LCh2Lab" c:identifier="vips_LCh2Lab" introspectable="0">
      <doc xml:space="preserve">Turn LCh to Lab.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="Lab2LCh" c:identifier="vips_Lab2LCh" introspectable="0">
      <doc xml:space="preserve">Turn Lab to LCh.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="Lab2LabQ" c:identifier="vips_Lab2LabQ" introspectable="0">
      <doc xml:space="preserve">Convert a Lab three-band float image to LabQ (#VIPS_CODING_LABQ).

See also: vips_LabQ2Lab().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="Lab2LabS" c:identifier="vips_Lab2LabS" introspectable="0">
      <doc xml:space="preserve">Turn Lab to LabS, signed 16-bit int fixed point.

See also: vips_LabQ2Lab().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="Lab2XYZ" c:identifier="vips_Lab2XYZ" introspectable="0">
      <doc xml:space="preserve">optional arguments:

Turn Lab to XYZ. The colour temperature defaults to D65, but can be
specified with @temp.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="LabQ2Lab" c:identifier="vips_LabQ2Lab" introspectable="0">
      <doc xml:space="preserve">Unpack a LabQ (#VIPS_CODING_LABQ) image to a three-band float image.

See also: vips_LabQ2Lab(), vips_LabQ2LabS(), vips_rad2float().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="LabQ2LabS"
              c:identifier="vips_LabQ2LabS"
              introspectable="0">
      <doc xml:space="preserve">Unpack a LabQ (#VIPS_CODING_LABQ) image to a three-band short image.

See also: vips_LabS2LabQ(), vips_LabQ2LabS(), vips_rad2float().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="LabQ2sRGB"
              c:identifier="vips_LabQ2sRGB"
              introspectable="0">
      <doc xml:space="preserve">Unpack a LabQ (#VIPS_CODING_LABQ) image to a three-band short image.

See also: vips_LabS2LabQ(), vips_LabQ2sRGB(), vips_rad2float().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="LabS2Lab" c:identifier="vips_LabS2Lab" introspectable="0">
      <doc xml:space="preserve">Convert a LabS three-band signed short image to a three-band float image.

See also: vips_LabS2Lab().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="LabS2LabQ"
              c:identifier="vips_LabS2LabQ"
              introspectable="0">
      <doc xml:space="preserve">Convert a LabS three-band signed short image to LabQ

See also: vips_LabQ2LabS().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <constant name="MAGIC_INTEL" value="3064394248" c:type="VIPS_MAGIC_INTEL">
      <doc xml:space="preserve">The first four bytes of a VIPS file in Intel byte ordering.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAGIC_SPARC" value="150120118" c:type="VIPS_MAGIC_SPARC">
      <doc xml:space="preserve">The first four bytes of a VIPS file in SPARC byte ordering.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAX_COORD" value="10000000" c:type="VIPS_MAX_COORD">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="META_EXIF_NAME"
              value="exif-data"
              c:type="VIPS_META_EXIF_NAME">
      <doc xml:space="preserve">The name that JPEG read and write operations use for the image's EXIF data.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_ICC_NAME"
              value="icc-profile-data"
              c:type="VIPS_META_ICC_NAME">
      <doc xml:space="preserve">The name we use to attach an ICC profile. The file read and write
operations for TIFF, JPEG, PNG and others use this item of metadata to
attach and save ICC profiles. The profile is updated by the
vips_icc_transform() operations.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_IMAGEDESCRIPTION"
              value="image-description"
              c:type="VIPS_META_IMAGEDESCRIPTION">
      <doc xml:space="preserve">The IMAGEDESCRIPTION tag. Often has useful metadata.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_IPCT_NAME"
              value="ipct-data"
              c:type="VIPS_META_IPCT_NAME">
      <doc xml:space="preserve">The name that read and write operations use for the image's IPCT data.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_LOADER" value="vips-loader" c:type="VIPS_META_LOADER">
      <doc xml:space="preserve">Record the name of the original loader here. Handy for hinting file formats
and for debugging.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_PHOTOSHOP_NAME"
              value="photoshop-data"
              c:type="VIPS_META_PHOTOSHOP_NAME">
      <doc xml:space="preserve">The name that TIFF read and write operations use for the image's
TIFFTAG_PHOTOSHOP data.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_RESOLUTION_UNIT"
              value="resolution-unit"
              c:type="VIPS_META_RESOLUTION_UNIT">
      <doc xml:space="preserve">The JPEG and TIFF read and write operations use this to record the
file's preferred unit for resolution.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_XML" value="xml-header" c:type="VIPS_META_XML">
      <doc xml:space="preserve">The original XML that was used to code the metadata after reading a VIPS
format file.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_XMP_NAME"
              value="xmp-data"
              c:type="VIPS_META_XMP_NAME">
      <doc xml:space="preserve">The name that read and write operations use for the image's XMP data.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="VipsObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="VipsObject"
           glib:get-type="vips_object_get_type"
           glib:type-struct="ObjectClass">
      <constructor name="new"
                   c:identifier="vips_object_new"
                   introspectable="0">
        <doc xml:space="preserve">g_object_new() the object, set any arguments with @set, call
vips_object_build() and return the complete object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new object</doc>
          <type name="Object" c:type="VipsObject*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">object to create</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">set arguments with this</doc>
            <type name="ObjectSetArguments" c:type="VipsObjectSetArguments"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="vips_object_new_from_string">
        <return-value transfer-ownership="full">
          <type name="Object" c:type="VipsObject*"/>
        </return-value>
        <parameters>
          <parameter name="object_class" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="p" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_property" c:identifier="vips_object_get_property">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="map" c:identifier="vips_object_map" introspectable="0">
        <doc xml:space="preserve">Call a function for all alive objects.
Stop when @fn returns non-%NULL and return that value.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first
non-%NULL value from @fn.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="fn" transfer-ownership="none">
            <doc xml:space="preserve">function to call for all objects</doc>
            <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="print_all" c:identifier="vips_object_print_all">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="print_summary_class"
                c:identifier="vips_object_print_summary_class">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="sanity_all" c:identifier="vips_object_sanity_all">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="set_property" c:identifier="vips_object_set_property">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="summary_class"
                c:identifier="vips_object_summary_class"
                introspectable="0">
        <doc xml:space="preserve">Generate a human-readable summary for a class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:space="preserve">class to summarise</doc>
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">write summary here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="build" invoker="build">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dump" invoker="dump" introspectable="0">
        <doc xml:space="preserve">Dump everything that vips knows about an object to a string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to dump</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">write dump here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="output_to_arg">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="postbuild">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="postclose">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="preclose" invoker="preclose">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rewind" invoker="rewind">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sanity" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="summary" invoker="summary" introspectable="0">
        <doc xml:space="preserve">Generate a human-readable summary for an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to summarise</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">write summary here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_string" invoker="to_string" introspectable="0">
        <doc xml:space="preserve">The inverse of vips_object_new_from_string(): turn @object into eg.
"VipsInterpolateSnohalo1(blur=.333333)".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to stringify</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">write string here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="argument_isset" c:identifier="vips_object_argument_isset">
        <doc xml:space="preserve">Convenience: has an argument been assigned. Useful for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the argument has been assigned.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="argument_needsstring"
              c:identifier="vips_object_argument_needsstring">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="build" c:identifier="vips_object_build">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="vips_object_dump" introspectable="0">
        <doc xml:space="preserve">Dump everything that vips knows about an object to a string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to dump</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">write dump here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument"
              c:identifier="vips_object_get_argument"
              introspectable="0">
        <doc xml:space="preserve">Look up the three things you need to work with a vips argument.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the pspec for this arg</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
          </parameter>
          <parameter name="argument_class" transfer-ownership="none">
            <doc xml:space="preserve">the argument_class for this arg</doc>
            <type name="ArgumentClass" c:type="VipsArgumentClass**"/>
          </parameter>
          <parameter name="argument_instance" transfer-ownership="none">
            <doc xml:space="preserve">the argument_instance for this arg</doc>
            <type name="ArgumentInstance" c:type="VipsArgumentInstance**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_flags"
              c:identifier="vips_object_get_argument_flags">
        <doc xml:space="preserve">Convenience: get the flags for an argument. Useful for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #VipsArgumentFlags for this argument.</doc>
          <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_priority"
              c:identifier="vips_object_get_argument_priority">
        <doc xml:space="preserve">Convenience: get the priority for an argument. Useful for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The priority of this argument.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_to_string"
              c:identifier="vips_object_get_argument_to_string">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="arg" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="vips_object_get_description">
        <doc xml:space="preserve">Fetch the object description. Useful for language bindings.

@object.description is only avaliable after _build(), which can be too
late. This function fetches from the instance, if possible, but falls back
to the class description if we are too early.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object description</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to fetch description from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="local_array"
              c:identifier="vips_object_local_array"
              introspectable="0">
        <doc xml:space="preserve">Make an array of NULL VipsObject pointers. When @parent closes, every
non-NULL pointer in the array will be unreffed and the array will be
freed. Handy for creating a set of temporary images for a function.

The array is NULL-terminated, ie. contains an extra NULL element at the
end.

Example:

|[
VipsObject **t;

t = vips_object_local_array( a, 5 );
if(
  vips_add( a, b, &amp;amp;t[0], NULL ) ||
  vips_invert( t[0], &amp;amp;t[1], NULL ) ||
  vips_add( t[1], t[0], &amp;amp;t[2], NULL ) ||
  vips_costra( t[2], out, NULL ) )
  return( -1 );
]|

See also: vips_object_local().</doc>
        <return-value>
          <doc xml:space="preserve">an array of NULL pointers of length @n</doc>
          <type name="Object" c:type="VipsObject**"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">objects unref when this object unrefs</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">array size</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="local_cb" c:identifier="vips_object_local_cb">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vobject" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="preclose" c:identifier="vips_object_preclose">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print_dump" c:identifier="vips_object_print_dump">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print_name" c:identifier="vips_object_print_name">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print_summary" c:identifier="vips_object_print_summary">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rewind" c:identifier="vips_object_rewind">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sanity" c:identifier="vips_object_sanity">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="vips_object_set" introspectable="0">
        <doc xml:space="preserve">Set a list of vips object arguments. For example:

|[
vips_object_set (operation,
  "input", in,
  "output", &amp;amp;out,
  NULL);
]|

Input arguments are given in-line, output arguments are given as pointers
to where the output value should be written.

See also: vips_object_set_valist(), vips_object_set_from_string().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to set arguments on</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of argument/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_argument_from_string"
              c:identifier="vips_object_set_argument_from_string">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_string"
              c:identifier="vips_object_set_from_string">
        <doc xml:space="preserve">Set object arguments from a string. The string can be something like
"a=12", or "a = 12, b = 13", or "fred". The string can optionally be
enclosed in brackets.

You'd typically use this between creating the object and building it.

See also: vips_object_set(), vips_object_build(),
vips_cache_operation_buildp().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to set arguments on</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">arguments as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_required" c:identifier="vips_object_set_required">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static" c:identifier="vips_object_set_static">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="static_object" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="vips_object_set_valist"
              introspectable="0">
        <doc xml:space="preserve">See vips_object_set().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to set arguments on</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of argument/value pairs</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="summary"
              c:identifier="vips_object_summary"
              introspectable="0">
        <doc xml:space="preserve">Generate a human-readable summary for an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to summarise</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">write summary here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string"
              c:identifier="vips_object_to_string"
              introspectable="0">
        <doc xml:space="preserve">The inverse of vips_object_new_from_string(): turn @object into eg.
"VipsInterpolateSnohalo1(blur=.333333)".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to stringify</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">write string here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_outputs" c:identifier="vips_object_unref_outputs">
        <doc xml:space="preserve">Unref all assigned output objects. Useful for language bindings.

After an object is built, all output args are owned by the caller. If
something goes wrong before then, we have to unref the outputs that have
been made so far. This function can also be useful for callers when
they've finished processing outputs themselves.

See also: vips_cache_operation_build().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to drop output refs from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="description" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nickname" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_object">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="constructed">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="static_object">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="argument_table">
        <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
      </field>
      <field name="nickname">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="description">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="preclose">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="close">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="postclose">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="local_memory">
        <type name="gsize" c:type="size_t"/>
      </field>
      <glib:signal name="close" when="last">
        <doc xml:space="preserve">The ::close signal is emitted once during object close. The object
is dying and may not work.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="postbuild" when="last">
        <doc xml:space="preserve">The ::postbuild signal is emitted once just after successful object
construction. Return non-zero to cause object construction to fail.</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
      </glib:signal>
      <glib:signal name="postclose" when="last">
        <doc xml:space="preserve">The ::postclose signal is emitted once after object close. The
object pointer is still valid, but nothing else.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="preclose" when="last">
        <doc xml:space="preserve">The ::preclose signal is emitted once just before object close
starts. The oject is still alive.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ObjectClass"
            c:type="VipsObjectClass"
            glib:is-gtype-struct-for="Object">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="build">
        <callback name="build">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="postbuild">
        <callback name="postbuild">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary_class" introspectable="0">
        <callback name="summary_class" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cls" transfer-ownership="none">
              <type name="gpointer" c:type="_VipsObjectClass*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary" introspectable="0">
        <callback name="summary" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">object to summarise</doc>
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">write summary here</doc>
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dump" introspectable="0">
        <callback name="dump" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">object to dump</doc>
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">write dump here</doc>
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sanity" introspectable="0">
        <callback name="sanity" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rewind">
        <callback name="rewind">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="preclose">
        <callback name="preclose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="postclose">
        <callback name="postclose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_from_string" introspectable="0">
        <callback name="new_from_string" introspectable="0">
          <return-value>
            <type name="Object" c:type="VipsObject*"/>
          </return-value>
          <parameters>
            <parameter name="string" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_string" introspectable="0">
        <callback name="to_string" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">object to stringify</doc>
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">write string here</doc>
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="output_needs_arg">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="output_to_arg">
        <callback name="output_to_arg">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="string" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="nickname">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="description">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="argument_table">
        <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
      </field>
      <field name="argument_table_traverse">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="argument_table_traverse_gtype">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="deprecated">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_vips_reserved1" introspectable="0">
        <callback name="_vips_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_vips_reserved2" introspectable="0">
        <callback name="_vips_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_vips_reserved3" introspectable="0">
        <callback name="_vips_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_vips_reserved4" introspectable="0">
        <callback name="_vips_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <method name="install_argument"
              c:identifier="vips_object_class_install_argument">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cls" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ObjectSetArguments" c:type="VipsObjectSetArguments">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Operation"
           c:symbol-prefix="operation"
           c:type="VipsOperation"
           parent="Object"
           abstract="1"
           glib:type-name="VipsOperation"
           glib:get-type="vips_operation_get_type"
           glib:type-struct="OperationClass">
      <constructor name="new" c:identifier="vips_operation_new">
        <doc xml:space="preserve">Return a new #VipsOperation with the specified nickname. Useful for
language bindings.

You'll need to set
any arguments and build the operation before you can use it. See
vips_call() for a higher-level way to make new operations.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new operation.</doc>
          <type name="Operation" c:type="VipsOperation*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">nickname of operation to create</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="get_flags" invoker="get_flags">
        <doc xml:space="preserve">Returns the set of flags for this operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="OperationFlags" c:type="VipsOperationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">operation to fetch flags from</doc>
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="invalidate" invoker="invalidate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="call_valist"
              c:identifier="vips_operation_call_valist"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="vips_operation_get_flags">
        <doc xml:space="preserve">Returns the set of flags for this operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="OperationFlags" c:type="VipsOperationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">operation to fetch flags from</doc>
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate" c:identifier="vips_operation_invalidate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="hash">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="found_hash">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="pixels">
        <type name="gint" c:type="int"/>
      </field>
      <glib:signal name="invalidate" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <enumeration name="OperationBoolean"
                 glib:type-name="VipsOperationBoolean"
                 glib:get-type="vips_operation_boolean_get_type"
                 c:type="VipsOperationBoolean">
      <doc xml:space="preserve">See also: vips_boolean().</doc>
      <member name="and"
              value="0"
              c:identifier="VIPS_OPERATION_BOOLEAN_AND"
              glib:nick="and">
        <doc xml:space="preserve">&amp;</doc>
      </member>
      <member name="or"
              value="1"
              c:identifier="VIPS_OPERATION_BOOLEAN_OR"
              glib:nick="or">
        <doc xml:space="preserve">|</doc>
      </member>
      <member name="eor"
              value="2"
              c:identifier="VIPS_OPERATION_BOOLEAN_EOR"
              glib:nick="eor">
        <doc xml:space="preserve">^</doc>
      </member>
      <member name="lshift"
              value="3"
              c:identifier="VIPS_OPERATION_BOOLEAN_LSHIFT"
              glib:nick="lshift">
        <doc xml:space="preserve">&gt;&gt;</doc>
      </member>
      <member name="rshift"
              value="4"
              c:identifier="VIPS_OPERATION_BOOLEAN_RSHIFT"
              glib:nick="rshift">
        <doc xml:space="preserve">&lt;&lt;</doc>
      </member>
      <member name="last"
              value="5"
              c:identifier="VIPS_OPERATION_BOOLEAN_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <callback name="OperationBuildFn" c:type="VipsOperationBuildFn">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OperationClass"
            c:type="VipsOperationClass"
            glib:is-gtype-struct-for="Operation">
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="usage" introspectable="0">
        <callback name="usage" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cls" transfer-ownership="none">
              <type name="gpointer" c:type="_VipsOperationClass*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">0 on success, or -1 on error.</doc>
            <type name="OperationFlags" c:type="VipsOperationFlags"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">operation to fetch flags from</doc>
              <type name="Operation" c:type="VipsOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flags">
        <type name="OperationFlags" c:type="VipsOperationFlags"/>
      </field>
      <field name="invalidate">
        <callback name="invalidate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <type name="Operation" c:type="VipsOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <method name="print_usage"
              c:identifier="vips_operation_class_print_usage"
              introspectable="0">
        <doc xml:space="preserve">Print a usage message for the operation to stdout.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation_class" transfer-ownership="none">
            <doc xml:space="preserve">class to print usage for</doc>
            <type name="OperationClass" c:type="VipsOperationClass*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="OperationComplex"
                 glib:type-name="VipsOperationComplex"
                 glib:get-type="vips_operation_complex_get_type"
                 c:type="VipsOperationComplex">
      <doc xml:space="preserve">See also: vips_complex().</doc>
      <member name="polar"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEX_POLAR"
              glib:nick="polar">
        <doc xml:space="preserve">convert to polar coordinates</doc>
      </member>
      <member name="rect"
              value="1"
              c:identifier="VIPS_OPERATION_COMPLEX_RECT"
              glib:nick="rect">
        <doc xml:space="preserve">convert to rectangular coordinates</doc>
      </member>
      <member name="conj"
              value="2"
              c:identifier="VIPS_OPERATION_COMPLEX_CONJ"
              glib:nick="conj">
        <doc xml:space="preserve">complex conjugate</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="VIPS_OPERATION_COMPLEX_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="OperationComplex2"
                 glib:type-name="VipsOperationComplex2"
                 glib:get-type="vips_operation_complex2_get_type"
                 c:type="VipsOperationComplex2">
      <doc xml:space="preserve">See also: vips_complex2().</doc>
      <member name="cross_phase"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEX2_CROSS_PHASE"
              glib:nick="cross-phase">
        <doc xml:space="preserve">convert to polar coordinates</doc>
      </member>
      <member name="last"
              value="1"
              c:identifier="VIPS_OPERATION_COMPLEX2_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="OperationComplexget"
                 glib:type-name="VipsOperationComplexget"
                 glib:get-type="vips_operation_complexget_get_type"
                 c:type="VipsOperationComplexget">
      <doc xml:space="preserve">See also: vips_complexget().</doc>
      <member name="real"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEXGET_REAL"
              glib:nick="real">
        <doc xml:space="preserve">get real component</doc>
      </member>
      <member name="imag"
              value="1"
              c:identifier="VIPS_OPERATION_COMPLEXGET_IMAG"
              glib:nick="imag">
        <doc xml:space="preserve">get imaginary component</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_OPERATION_COMPLEXGET_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <bitfield name="OperationFlags"
              glib:type-name="VipsOperationFlags"
              glib:get-type="vips_operation_flags_get_type"
              c:type="VipsOperationFlags">
      <doc xml:space="preserve">Flags we associate with an operation.

@VIPS_OPERATION_SEQUENTIAL means that the operation works like vips_conv():
it can process images top-to-bottom with only small non-local
references.

Every scan-line must be requested, you are not allowed to skip
ahead, but as a special case, the very first request can be for a region
not at the top of the image. In this case, the first part of the image will
be read and discarded

@VIPS_OPERATION_SEQUENTIAL_UNBUFFERED means that the operation works like
vips_copy(): it can process images top-to-bottom and makes no
non-local references.

Every scan-line must be requested, you are not allowed to skip
ahead, but as a special case, the very first request can be for a region
not at the top of the image. In this case, the first part of the image will
be read and discarded

@VIPS_OPERATION_NOCACHE means that the operation must not be cached by
vips.

@VIPS_OPERATION_DEPRECATED means this is an old operation kept in vips for
compatibility only and should be hidden from users.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_OPERATION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flags</doc>
      </member>
      <member name="sequential"
              value="1"
              c:identifier="VIPS_OPERATION_SEQUENTIAL"
              glib:nick="sequential">
        <doc xml:space="preserve">can work sequentially with a small buffer</doc>
      </member>
      <member name="sequential_unbuffered"
              value="2"
              c:identifier="VIPS_OPERATION_SEQUENTIAL_UNBUFFERED"
              glib:nick="sequential-unbuffered">
        <doc xml:space="preserve">can work sequentially with no buffer</doc>
      </member>
      <member name="nocache"
              value="4"
              c:identifier="VIPS_OPERATION_NOCACHE"
              glib:nick="nocache">
        <doc xml:space="preserve">must not be cached</doc>
      </member>
      <member name="deprecated"
              value="8"
              c:identifier="VIPS_OPERATION_DEPRECATED"
              glib:nick="deprecated">
        <doc xml:space="preserve">a compatibility thing</doc>
      </member>
    </bitfield>
    <enumeration name="OperationMath"
                 glib:type-name="VipsOperationMath"
                 glib:get-type="vips_operation_math_get_type"
                 c:type="VipsOperationMath">
      <doc xml:space="preserve">See also: vips_math().</doc>
      <member name="sin"
              value="0"
              c:identifier="VIPS_OPERATION_MATH_SIN"
              glib:nick="sin">
        <doc xml:space="preserve">sin(), angles in degrees</doc>
      </member>
      <member name="cos"
              value="1"
              c:identifier="VIPS_OPERATION_MATH_COS"
              glib:nick="cos">
        <doc xml:space="preserve">cos(), angles in degrees</doc>
      </member>
      <member name="tan"
              value="2"
              c:identifier="VIPS_OPERATION_MATH_TAN"
              glib:nick="tan">
        <doc xml:space="preserve">tan(), angles in degrees</doc>
      </member>
      <member name="asin"
              value="3"
              c:identifier="VIPS_OPERATION_MATH_ASIN"
              glib:nick="asin">
        <doc xml:space="preserve">asin(), angles in degrees</doc>
      </member>
      <member name="acos"
              value="4"
              c:identifier="VIPS_OPERATION_MATH_ACOS"
              glib:nick="acos">
        <doc xml:space="preserve">acos(), angles in degrees</doc>
      </member>
      <member name="atan"
              value="5"
              c:identifier="VIPS_OPERATION_MATH_ATAN"
              glib:nick="atan">
        <doc xml:space="preserve">atan(), angles in degrees</doc>
      </member>
      <member name="log"
              value="6"
              c:identifier="VIPS_OPERATION_MATH_LOG"
              glib:nick="log">
        <doc xml:space="preserve">log base e</doc>
      </member>
      <member name="log10"
              value="7"
              c:identifier="VIPS_OPERATION_MATH_LOG10"
              glib:nick="log10">
        <doc xml:space="preserve">log base 10</doc>
      </member>
      <member name="exp"
              value="8"
              c:identifier="VIPS_OPERATION_MATH_EXP"
              glib:nick="exp">
        <doc xml:space="preserve">e to the something</doc>
      </member>
      <member name="exp10"
              value="9"
              c:identifier="VIPS_OPERATION_MATH_EXP10"
              glib:nick="exp10">
        <doc xml:space="preserve">10 to the something</doc>
      </member>
      <member name="last"
              value="10"
              c:identifier="VIPS_OPERATION_MATH_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="OperationMath2"
                 glib:type-name="VipsOperationMath2"
                 glib:get-type="vips_operation_math2_get_type"
                 c:type="VipsOperationMath2">
      <doc xml:space="preserve">See also: vips_math().</doc>
      <member name="pow"
              value="0"
              c:identifier="VIPS_OPERATION_MATH2_POW"
              glib:nick="pow">
        <doc xml:space="preserve">pow( left, right )</doc>
      </member>
      <member name="wop"
              value="1"
              c:identifier="VIPS_OPERATION_MATH2_WOP"
              glib:nick="wop">
        <doc xml:space="preserve">pow( right, left )</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_OPERATION_MATH2_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="OperationMorphology"
                 glib:type-name="VipsOperationMorphology"
                 glib:get-type="vips_operation_morphology_get_type"
                 c:type="VipsOperationMorphology">
      <doc xml:space="preserve">More like hit-miss, really.

See also: vips_morph().</doc>
      <member name="erode"
              value="0"
              c:identifier="VIPS_OPERATION_MORPHOLOGY_ERODE"
              glib:nick="erode">
        <doc xml:space="preserve">true if all set</doc>
      </member>
      <member name="dilate"
              value="1"
              c:identifier="VIPS_OPERATION_MORPHOLOGY_DILATE"
              glib:nick="dilate">
        <doc xml:space="preserve">true if one set</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_OPERATION_MORPHOLOGY_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="OperationRelational"
                 glib:type-name="VipsOperationRelational"
                 glib:get-type="vips_operation_relational_get_type"
                 c:type="VipsOperationRelational">
      <doc xml:space="preserve">See also: vips_relational().</doc>
      <member name="equal"
              value="0"
              c:identifier="VIPS_OPERATION_RELATIONAL_EQUAL"
              glib:nick="equal">
        <doc xml:space="preserve">==</doc>
      </member>
      <member name="noteq"
              value="1"
              c:identifier="VIPS_OPERATION_RELATIONAL_NOTEQ"
              glib:nick="noteq">
        <doc xml:space="preserve">!=</doc>
      </member>
      <member name="less"
              value="2"
              c:identifier="VIPS_OPERATION_RELATIONAL_LESS"
              glib:nick="less">
        <doc xml:space="preserve">&lt;</doc>
      </member>
      <member name="lesseq"
              value="3"
              c:identifier="VIPS_OPERATION_RELATIONAL_LESSEQ"
              glib:nick="lesseq">
        <doc xml:space="preserve">&lt;=</doc>
      </member>
      <member name="more"
              value="4"
              c:identifier="VIPS_OPERATION_RELATIONAL_MORE"
              glib:nick="more">
        <doc xml:space="preserve">&gt;</doc>
      </member>
      <member name="moreeq"
              value="5"
              c:identifier="VIPS_OPERATION_RELATIONAL_MOREEQ"
              glib:nick="moreeq">
        <doc xml:space="preserve">&gt;=</doc>
      </member>
      <member name="last"
              value="6"
              c:identifier="VIPS_OPERATION_RELATIONAL_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="OperationRound"
                 glib:type-name="VipsOperationRound"
                 glib:get-type="vips_operation_round_get_type"
                 c:type="VipsOperationRound">
      <doc xml:space="preserve">See also: vips_round().</doc>
      <member name="rint"
              value="0"
              c:identifier="VIPS_OPERATION_ROUND_RINT"
              glib:nick="rint">
        <doc xml:space="preserve">round to nearest</doc>
      </member>
      <member name="ceil"
              value="1"
              c:identifier="VIPS_OPERATION_ROUND_CEIL"
              glib:nick="ceil">
        <doc xml:space="preserve">the smallest integral value not less than</doc>
      </member>
      <member name="floor"
              value="2"
              c:identifier="VIPS_OPERATION_ROUND_FLOOR"
              glib:nick="floor">
        <doc xml:space="preserve">largest integral value not greater than</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="VIPS_OPERATION_ROUND_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="PCS"
                 glib:type-name="VipsPCS"
                 glib:get-type="vips_pcs_get_type"
                 c:type="VipsPCS">
      <doc xml:space="preserve">Pick a Profile Connection Space for vips_icc_import() and
vips_icc_export(). LAB is usually best, XYZ can be more convenient in some
cases.</doc>
      <member name="lab" value="0" c:identifier="VIPS_PCS_LAB" glib:nick="lab">
        <doc xml:space="preserve">use CIELAB D65 as the Profile Connection Space</doc>
      </member>
      <member name="xyz" value="1" c:identifier="VIPS_PCS_XYZ" glib:nick="xyz">
        <doc xml:space="preserve">use XYZ as the Profile Connection Space</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="VIPS_PCS_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <enumeration name="Precision"
                 glib:type-name="VipsPrecision"
                 glib:get-type="vips_precision_get_type"
                 c:type="VipsPrecision">
      <doc xml:space="preserve">How accurate an operation should be.</doc>
      <member name="integer"
              value="0"
              c:identifier="VIPS_PRECISION_INTEGER"
              glib:nick="integer">
        <doc xml:space="preserve">int everywhere</doc>
      </member>
      <member name="float"
              value="1"
              c:identifier="VIPS_PRECISION_FLOAT"
              glib:nick="float">
        <doc xml:space="preserve">float everywhere</doc>
      </member>
      <member name="approximate"
              value="2"
              c:identifier="VIPS_PRECISION_APPROXIMATE"
              glib:nick="approximate">
        <doc xml:space="preserve">approximate integer output</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="VIPS_PRECISION_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <record name="Progress" c:type="VipsProgress">
      <doc xml:space="preserve">A structure available to eval callbacks giving information on evaluation
progress. See #VipsImage::eval.</doc>
      <field name="im" writable="1">
        <type name="gpointer" c:type="_VipsImage*"/>
      </field>
      <field name="run" writable="1">
        <doc xml:space="preserve">Time we have been running</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="eta" writable="1">
        <doc xml:space="preserve">Estimated seconds of computation left</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="tpels" writable="1">
        <doc xml:space="preserve">Number of pels we expect to calculate</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="npels" writable="1">
        <doc xml:space="preserve">Number of pels calculated so far</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="percent" writable="1">
        <doc xml:space="preserve">Percent complete</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="start" writable="1">
        <doc xml:space="preserve">Start time</doc>
        <type name="GLib.Timer" c:type="GTimer*"/>
      </field>
      <function name="set" c:identifier="vips_progress_set">
        <doc xml:space="preserve">If set, vips will print messages about the progress of computation to
stdout. This can also be enabled with the --vips-progress option, or by
setting the environment variable VIPS_PROGRESS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable progress messages</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="RefString"
            c:type="VipsRefString"
            glib:type-name="VipsRefString"
            glib:get-type="vips_ref_string_get_type"
            c:symbol-prefix="ref_string">
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_ref_string_new">
        <doc xml:space="preserve">Create a new refstring. These are reference-counted immutable strings, used
to store string data in vips image metadata.

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #VipsRefString.</doc>
          <type name="RefString" c:type="VipsRefString*"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">string to store</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_ref_string_get">
        <doc xml:space="preserve">Get a pointer to the private string inside a refstr. Handy for language
bindings.

See also: vips_value_get_ref_string().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The C string held by @refstr.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="refstr" transfer-ownership="none">
            <doc xml:space="preserve">the #VipsRefString to fetch from</doc>
            <type name="RefString" c:type="VipsRefString*"/>
          </instance-parameter>
          <parameter name="length"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">return length here, optionally</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="Region"
           c:symbol-prefix="region"
           c:type="VipsRegion"
           parent="Object"
           glib:type-name="VipsRegion"
           glib:get-type="vips_region_get_type"
           glib:type-struct="RegionClass">
      <doc xml:space="preserve">A small part of a #VipsImage. @valid holds the left/top/width/height of the
area of pixels that are available from the region.

See also: VIPS_REGION_ADDR(), vips_region_new(), vips_region_prepare().</doc>
      <constructor name="new" c:identifier="vips_region_new">
        <doc xml:space="preserve">Create a region. #VipsRegion s start out empty, you need to call
vips_region_prepare() to fill them with pixels.

See also: vips_region_prepare().</doc>
        <return-value transfer-ownership="full">
          <type name="Region" c:type="VipsRegion*"/>
        </return-value>
        <parameters>
          <parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">image to create this region on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="dump_all" c:identifier="vips_region_dump_all">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="prepare_many"
                c:identifier="vips_region_prepare_many"
                introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="reg" transfer-ownership="none">
            <type name="Region" c:type="VipsRegion**"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <type c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </function>
      <method name="black" c:identifier="vips_region_black">
        <doc xml:space="preserve">Paints 0 into the valid part of @reg.

See also: vips_region_paint().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="buffer"
              c:identifier="vips_region_buffer"
              introspectable="0">
        <doc xml:space="preserve">The region is transformed so that at least @r pixels are available as a
memory buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">#VipsRect of pixels you need to be able to address</doc>
            <type c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="vips_region_copy" introspectable="0">
        <doc xml:space="preserve">Copy from one region to another. Copy area @r from inside @reg to @dest,
positioning the area of pixels at @x, @y. The two regions must have pixels
which are the same size.

See also: vips_region_paint().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">source region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">destination region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">#VipsRect of pixels you need to copy</doc>
            <type c:type="VipsRect*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">postion of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">postion of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="equalsregion" c:identifier="vips_region_equalsregion">
        <doc xml:space="preserve">Do two regions point to the same piece of image? ie.

|[
	VIPS_REGION_ADDR( reg1, x, y ) == VIPS_REGION_ADDR( reg2, x, y ) &amp;amp;&amp;amp;
	*VIPS_REGION_ADDR( reg1, x, y ) ==
		*VIPS_REGION_ADDR( reg2, x, y ) for all x, y, reg1, reg2.
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">non-zero on equality.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg1" transfer-ownership="none">
            <doc xml:space="preserve">region to test</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="reg2" transfer-ownership="none">
            <doc xml:space="preserve">region to test</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="image" c:identifier="vips_region_image" introspectable="0">
        <doc xml:space="preserve">The region is transformed so that at least @r pixels are available directly
from the image. The image needs to be a memory buffer or represent a file
on disc that has been mapped or can be mapped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">#VipsRect of pixels you need to be able to address</doc>
            <type c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="invalidate" c:identifier="vips_region_invalidate">
        <doc xml:space="preserve">Mark a region as containing invalid pixels. Calling this function means
that the next time vips_region_prepare() is called, the region will be
recalculated.

This is faster than calling vips_image_invalidate_all(), but obviously only
affects a single region.

See also: vips_image_invalidate_all(), vips_region_prepare().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to invalidate</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="paint" c:identifier="vips_region_paint" introspectable="0">
        <doc xml:space="preserve">Paints @value into @reg covering rectangle @r. For int images, @value is
passed to memset(), so it usually needs to be 0 or 255. For float images,
value is cast to a float and copied in to each band element.

@r is clipped against
@reg-&gt;valid.

See also: vips_region_black().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">area to paint</doc>
            <type c:type="VipsRect*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="paint_pel"
              c:identifier="vips_region_paint_pel"
              introspectable="0">
        <doc xml:space="preserve">Paints @ink into @reg covering rectangle @r. @r is clipped against
@reg-&gt;valid.

@ink should be a byte array of the same size as an image pixel containing
the binary value to write into the pixels.

See also: vips_region_paint().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">area to paint</doc>
            <type c:type="VipsRect*"/>
          </parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve">value to paint</doc>
            <type name="Pel" c:type="VipsPel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="position" c:identifier="vips_region_position">
        <doc xml:space="preserve">Set the position of a region. This only affects reg-&gt;valid, ie. the way
pixels are addressed, not reg-&gt;data, the pixels which are addressed. Clip
against the size of the image. Do not allow negative positions, or
positions outside the image.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">position to move to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">position to move to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare"
              c:identifier="vips_region_prepare"
              introspectable="0">
        <doc xml:space="preserve">vips_region_prepare() fills @reg with pixels. After calling,
you can address at least the area @r with VIPS_REGION_ADDR() and get
valid pixels.

vips_region_prepare() runs in-line, that is, computation is done by
the calling thread, no new threads are involved, and computation
blocks until the pixels are ready.

Use vips_sink_screen() to calculate an area of pixels in the
background.

See also: vips_sink_screen(),
vips_region_prepare_to().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to prepare</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">#VipsRect of pixels you need to be able to address</doc>
            <type c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_to"
              c:identifier="vips_region_prepare_to"
              introspectable="0">
        <doc xml:space="preserve">Like vips_region_prepare(): fill @reg with data, ready to be read from by
our caller. Unlike vips_region_prepare(), rather than allocating memory
local to @reg for the result, we guarantee that we will fill the pixels
in @dest at offset @x, @y. In other words, we generate an extra copy
operation if necessary.

Also unlike vips_region_prepare(), @dest is not set up for writing for
you with
vips_region_buffer(). You can
point @dest at anything, and pixels really will be written there.
This makes vips_region_prepare_to() useful for making the ends of
pipelines, since
it (effectively) makes a break in the pipe.

See also: vips_region_prepare(), vips_sink_disc().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to prepare</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">region to write to</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">#VipsRect of pixels you need to be able to address</doc>
            <type c:type="VipsRect*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">postion of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">postion of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="region"
              c:identifier="vips_region_region"
              introspectable="0">
        <doc xml:space="preserve">Make VIPS_REGION_ADDR() on @reg go to @dest instead.

@r is the part of @reg which you want to be able to address (this
effectively becomes the valid field), (@x, @y) is the top LH corner of the
corresponding area in @dest.

Performs all clipping necessary to ensure that @reg-&gt;valid is indeed
valid.

If the region we attach to is modified, we can be left with dangling
pointers! If the region we attach to is on another image, the two images
must have
the same sizeof( pel ).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">region to connect to</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">#VipsRect of pixels you need to be able to address</doc>
            <type c:type="VipsRect*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">postion of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">postion of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink"
              c:identifier="vips_region_shrink"
              introspectable="0">
        <doc xml:space="preserve">Write the pixels @target in @to from the x2 larger area in @from.
Non-complex uncoded images and LABQ only.

See also: vips_region_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">source region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">destination region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">#VipsRect of pixels you need to copy</doc>
            <type c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="im">
        <doc xml:space="preserve">the #VipsImage that this region is defined on</doc>
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="valid" introspectable="0">
        <doc xml:space="preserve">the #VipsRect of pixels that this region represents</doc>
        <type c:type="VipsRect"/>
      </field>
      <field name="type" introspectable="0" readable="0" private="1">
        <type c:type="RegionType"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="Pel" c:type="VipsPel*"/>
      </field>
      <field name="bpl" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="seq" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="window" introspectable="0" readable="0" private="1">
        <type c:type="VipsWindow*"/>
      </field>
      <field name="buffer" introspectable="0" readable="0" private="1">
        <type c:type="VipsBuffer*"/>
      </field>
      <field name="invalid" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <record name="RegionClass"
            c:type="VipsRegionClass"
            glib:is-gtype-struct-for="Region">
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
    </record>
    <callback name="SListFold2Fn" c:type="VipsSListFold2Fn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="item"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="c"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SListMap2Fn" c:type="VipsSListMap2Fn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="item"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SListMap4Fn" c:type="VipsSListMap4Fn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="item"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="c"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="d"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="SaveString"
                c:symbol-prefix="save_string"
                glib:type-name="VipsSaveString"
                glib:get-type="vips_save_string_get_type">
    </glib:boxed>
    <enumeration name="Saveable"
                 glib:type-name="VipsSaveable"
                 glib:get-type="vips_saveable_get_type"
                 c:type="VipsSaveable">
      <doc xml:space="preserve">See also: #VipsForeignSave.</doc>
      <member name="mono"
              value="0"
              c:identifier="VIPS_SAVEABLE_MONO"
              glib:nick="mono">
        <doc xml:space="preserve">1 band (eg. CSV)</doc>
      </member>
      <member name="rgb"
              value="1"
              c:identifier="VIPS_SAVEABLE_RGB"
              glib:nick="rgb">
        <doc xml:space="preserve">1 or 3 bands (eg. PPM)</doc>
      </member>
      <member name="rgba"
              value="2"
              c:identifier="VIPS_SAVEABLE_RGBA"
              glib:nick="rgba">
        <doc xml:space="preserve">1, 2, 3 or 4 bands (eg. PNG)</doc>
      </member>
      <member name="rgba_only"
              value="3"
              c:identifier="VIPS_SAVEABLE_RGBA_ONLY"
              glib:nick="rgba-only">
        <doc xml:space="preserve">3 or 4 bands (eg. WEBP)</doc>
      </member>
      <member name="rgb_cmyk"
              value="4"
              c:identifier="VIPS_SAVEABLE_RGB_CMYK"
              glib:nick="rgb-cmyk">
        <doc xml:space="preserve">1, 3 or 4 bands (eg. JPEG)</doc>
      </member>
      <member name="any"
              value="5"
              c:identifier="VIPS_SAVEABLE_ANY"
              glib:nick="any">
        <doc xml:space="preserve">any number of bands (eg. TIFF)</doc>
      </member>
      <member name="last"
              value="6"
              c:identifier="VIPS_SAVEABLE_LAST"
              glib:nick="last">
      </member>
    </enumeration>
    <callback name="StartFn" c:type="VipsStartFn">
      <doc xml:space="preserve">Start a new processing sequence for this generate function. This allocates
per-thread state, such as an input region.

See also: vips_start_one(), vips_start_many().</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a new sequence value</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">image being calculated</doc>
          <type name="gpointer" c:type="_VipsImage*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="StopFn" c:type="VipsStopFn">
      <doc xml:space="preserve">Stop a processing sequence. This frees
per-thread state, such as an input region.

See also: vips_stop_one(), vips_stop_many().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="seq"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">sequence value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="TRANSFORM_SCALE" value="1" c:type="VIPS_TRANSFORM_SCALE">
      <doc xml:space="preserve">#VIPS_TRANSFORM_SHIFT as a multiplicative constant.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TRANSFORM_SHIFT" value="6" c:type="VIPS_TRANSFORM_SHIFT">
      <doc xml:space="preserve">Many of the vips interpolators use fixed-point arithmetic for coordinate
calculation. This is how many bits of precision they use.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Thing"
            c:type="VipsThing"
            glib:type-name="VipsThing"
            glib:get-type="vips_thing_get_type"
            c:symbol-prefix="thing">
      <field name="i" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <constructor name="new" c:identifier="vips_thing_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #VipsThing.</doc>
          <type name="Thing" c:type="VipsThing*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </record>
    <enumeration name="Token"
                 glib:type-name="VipsToken"
                 glib:get-type="vips_token_get_type"
                 c:type="VipsToken">
      <member name="left"
              value="1"
              c:identifier="VIPS_TOKEN_LEFT"
              glib:nick="left">
      </member>
      <member name="right"
              value="2"
              c:identifier="VIPS_TOKEN_RIGHT"
              glib:nick="right">
      </member>
      <member name="string"
              value="3"
              c:identifier="VIPS_TOKEN_STRING"
              glib:nick="string">
      </member>
      <member name="equals"
              value="4"
              c:identifier="VIPS_TOKEN_EQUALS"
              glib:nick="equals">
      </member>
      <member name="comma"
              value="5"
              c:identifier="VIPS_TOKEN_COMMA"
              glib:nick="comma">
      </member>
    </enumeration>
    <callback name="TypeMap2Fn" c:type="VipsTypeMap2Fn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeMapFn" c:type="VipsTypeMapFn">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function name="XYZ2Lab" c:identifier="vips_XYZ2Lab" introspectable="0">
      <doc xml:space="preserve">optional arguments:

Turn XYZ to Lab, optionally specifying the colour temperature. @temp
defaults to D65.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="XYZ2Yxy" c:identifier="vips_XYZ2Yxy" introspectable="0">
      <doc xml:space="preserve">Turn XYZ to Yxy.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="XYZ2scRGB"
              c:identifier="vips_XYZ2scRGB"
              introspectable="0">
      <doc xml:space="preserve">Turn XYZ to scRGB.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="Yxy2Lab" c:identifier="vips_Yxy2Lab" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="Yxy2XYZ" c:identifier="vips_Yxy2XYZ" introspectable="0">
      <doc xml:space="preserve">Turn XYZ to Yxy.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="_argument_get_instance"
              c:identifier="vips__argument_get_instance"
              introspectable="0">
      <doc xml:space="preserve">Convenience ... given the VipsArgumentClass, get the VipsArgumentInstance.</doc>
      <return-value>
        <type name="ArgumentInstance" c:type="VipsArgumentInstance*"/>
      </return-value>
      <parameters>
        <parameter name="argument_class" transfer-ownership="none">
          <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="_argument_table_lookup"
              c:identifier="vips__argument_table_lookup"
              introspectable="0">
      <return-value>
        <type name="Argument" c:type="VipsArgument*"/>
      </return-value>
      <parameters>
        <parameter name="argument_class" transfer-ownership="none">
          <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="_object_set_member" c:identifier="vips__object_set_member">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="member" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject**"/>
        </parameter>
        <parameter name="argument" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="abs" c:identifier="vips_abs" introspectable="0">
      <doc xml:space="preserve">This operation finds the absolute value of an image. It does a copy for
unsigned integer types, negate for negative values in
signed integer types, &lt;function&gt;fabs(3)&lt;/function&gt; for
float types, and calculates modulus for complex
types.

See also: vips_sign().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="acos" c:identifier="vips_acos" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_ACOS on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="add" c:identifier="vips_add" introspectable="0">
      <doc xml:space="preserve">This operation calculates @in1 + @in2 and writes the result to @out.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;), then the
following table is used to determine the output type:

&lt;table&gt;
  &lt;title&gt;VipsAdd type promotion&lt;/title&gt;
  &lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
    &lt;thead&gt;
      &lt;row&gt;
        &lt;entry&gt;input type&lt;/entry&gt;
        &lt;entry&gt;output type&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;uchar&lt;/entry&gt;
        &lt;entry&gt;ushort&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;char&lt;/entry&gt;
        &lt;entry&gt;short&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;ushort&lt;/entry&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;short&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;int&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;float&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double&lt;/entry&gt;
        &lt;entry&gt;double&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

Operations on integer images are performed using the processor's vector unit,
if possible. Disable this with --vips-novector or IM_NOVECTOR.

See also: vips_subtract(), vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="add_option_entries" c:identifier="vips_add_option_entries">
      <doc xml:space="preserve">Add the standard vips %GOptionEntry to a %GOptionGroup.

See also: g_option_group_new().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="option_group" transfer-ownership="none">
          <doc xml:space="preserve">group to add to</doc>
          <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
        </parameter>
      </parameters>
    </function>
    <function name="analyzeload"
              c:identifier="vips_analyzeload"
              introspectable="0">
      <doc xml:space="preserve">Load an Analyze 6.0 file. If @filename is "fred.img", this will look for
an image header called "fred.hdr" and pixel data in "fred.img". You can
also load "fred" or "fred.hdr".

Images are
loaded lazilly and byte-swapped, if necessary. The Analyze metadata is read
and attached.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="andimage" c:identifier="vips_andimage" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_AND on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="andimage_const"
              c:identifier="vips_andimage_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_AND on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="andimage_const1"
              c:identifier="vips_andimage_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_AND on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="argument_class_map"
              c:identifier="vips_argument_class_map"
              moved-to="ArgumentClass.map"
              introspectable="0">
      <doc xml:space="preserve">And loop over a class. Same as ^^, but with no VipsArgumentInstance.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object_class" transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <type name="ArgumentClassMapFn" c:type="VipsArgumentClassMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="argument_map"
              c:identifier="vips_argument_map"
              moved-to="Argument.map"
              introspectable="0">
      <doc xml:space="preserve">Loop over the vips_arguments to an object. Stop when @fn returns non-%NULL
and return that value.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first
non-%NULL value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">object whose args should be enumerated</doc>
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:space="preserve">call this function for every argument</doc>
          <type name="ArgumentMapFn" c:type="VipsArgumentMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="array_image_empty"
              c:identifier="vips_array_image_empty"
              moved-to="ArrayImage.empty">
      <doc xml:space="preserve">Make an empty image array.
Handy with vips_array_image_add() for bindings
which can't handle object array arguments.

See also: vips_array_image_add().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #VipsArrayImage.</doc>
        <type name="ArrayImage" c:type="VipsArrayImage*"/>
      </return-value>
    </function>
    <function name="arrayjoin"
              c:identifier="vips_arrayjoin"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Lay out the images in @in in a grid. The grid is @across images across and
however high is necessary to use up all of @in. Images are set down
left-to-right and top-to-bottom. @across defaults to @n.

Each input image is placed with a box of size @hspacing by @vspacing
pixels and cropped. These default to the largest width and largest height
of the input images.

Space between images is filled with @background. This defaults to 0
(black).

Images are positioned within their @hspacing by @vspacing box at low,
centre or high coordinate values, controlled by @halign and @valign. These
default to left-top.

Boxes are joined and separated by @shim pixels. This defaults to 0.

If the number of bands in the input images differs, all but one of the
images must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the n-band images are operated upon.

The input images are cast up to the smallest common type (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_join(), vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">array of input images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="asin" c:identifier="vips_asin" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_ASIN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="atan" c:identifier="vips_atan" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_ATAN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="autorot" c:identifier="vips_autorot" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Look at the exif tags and rotate the image to make it upright. The
orientation tag is removed from @out to prevent accidental double rotation.

Read @angle to find the amount the image was rotated by.

See also: vips_rot().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="autorot_get_angle" c:identifier="vips_autorot_get_angle">
      <doc xml:space="preserve">Examine the metadata on @im and return the #VipsAngle to rotate by to turn
the image upright.

See also: vips_autorot().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #VipsAngle to rotate by to make the image upright.</doc>
        <type name="Angle" c:type="VipsAngle"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to fetch orientation from</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="avg" c:identifier="vips_avg" introspectable="0">
      <doc xml:space="preserve">This operation finds the average value in an image. It operates on all
bands of the input image: use vips_stats() if you need to calculate an
average for each band. For complex images, return the average modulus.

See also: vips_stats(), vips_bandmean(), vips_deviate(), vips_rank()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output pixel average</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_is8bit"
              c:identifier="vips_band_format_is8bit"
              moved-to="BandFormat.is8bit">
      <doc xml:space="preserve">Return %TRUE if @format is uchar or schar.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_iscomplex"
              c:identifier="vips_band_format_iscomplex"
              moved-to="BandFormat.iscomplex">
      <doc xml:space="preserve">Return %TRUE if @fmt is one of the complex types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isfloat"
              c:identifier="vips_band_format_isfloat"
              moved-to="BandFormat.isfloat">
      <doc xml:space="preserve">Return %TRUE if @format is one of the float types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isint"
              c:identifier="vips_band_format_isint"
              moved-to="BandFormat.isint">
      <doc xml:space="preserve">Return %TRUE if @format is one of the integer types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isuint"
              c:identifier="vips_band_format_isuint"
              moved-to="BandFormat.isuint">
      <doc xml:space="preserve">Return %TRUE if @format is one of the unsigned integer types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="bandand" c:identifier="vips_bandand" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_AND on an image. See
vips_bandbool().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandbool" c:identifier="vips_bandbool" introspectable="0">
      <doc xml:space="preserve">Perform various boolean operations across the bands of an image. For
example, a three-band uchar image operated on with
#VIPS_OPERATION_BOOLEAN_AND will produce a one-band uchar image where each
pixel is the bitwise and of the band elements of the corresponding pixel in
the input image.

The output image is the same format as the input image for integer
types. Float types are cast to int before processing. Complex types are not
supported.

The output image always has one band.

This operation is useful in conjuction with vips_relational(). You can use
it to see if all image bands match exactly.

See also: vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="boolean" transfer-ownership="none">
          <doc xml:space="preserve">boolean operation to perform</doc>
          <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandeor" c:identifier="vips_bandeor" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_EOR on an image. See
vips_bandbool().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandfold" c:identifier="vips_bandfold" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Fold up an image horizontally: width is collapsed into bands.
Use @factor to set how much to fold by: @factor 3, for example, will make
the output image three times narrower than the input, and with three times
as many bands. By default the whole of the input width is folded up.

See also: vips_csvload(), vips_bandunfold().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandjoin" c:identifier="vips_bandjoin" introspectable="0">
      <doc xml:space="preserve">Join a set of images together, bandwise.

If the images
have n and m bands, then the output image will have n + m
bands, with the first n coming from the first image and the last m
from the second.

If the images differ in size, the smaller images are enlarged to match the
larger by adding zero pixels along the bottom and right.

The input images are cast up to the smallest common type (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">array of input images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandjoin2"
              c:identifier="vips_bandjoin2"
              introspectable="0">
      <doc xml:space="preserve">Join a pair of images together, bandwise. See vips_bandjoin().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in1" transfer-ownership="none">
          <doc xml:space="preserve">first input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in2" transfer-ownership="none">
          <doc xml:space="preserve">second input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandjoin_const"
              c:identifier="vips_bandjoin_const"
              introspectable="0">
      <doc xml:space="preserve">Append a set of constant bands to an image.

See also: vips_bandjoin().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">array of input images</doc>
          <array length="3" zero-terminated="0" c:type="VipsImage*">
            <type name="Image" c:type="VipsImage"/>
          </array>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants to append</doc>
          <array length="3" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandjoin_const1"
              c:identifier="vips_bandjoin_const1"
              introspectable="0">
      <doc xml:space="preserve">Append a single constant band to an image.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant to append</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandmean" c:identifier="vips_bandmean" introspectable="0">
      <doc xml:space="preserve">This operation writes a one-band image where each pixel is the average of
the bands for that pixel in the input image. The output band format is
the same as the input band format. Integer types use round-to-nearest
averaging.

See also: vips_add(), vips_avg(), vips_recomb()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandor" c:identifier="vips_bandor" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_OR on an image. See
vips_bandbool().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandrank" c:identifier="vips_bandrank" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Sorts the images @in band-element-wise, then outputs an
image in which each band element is selected from the sorted list by the
@index parameter. For example, if @index
is zero, then each output band element will be the minimum of all the
corresponding input band elements.

By default, @index is -1, meaning pick the median value.

It works for any uncoded, non-complex image type. Images are cast up to the
smallest common-format.

Any image can have either 1 band or n bands, where n is the same for all
the non-1-band images. Single band images are then effectively copied to
make n-band images.

Smaller input images are expanded by adding black pixels.

See also: vips_rank().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">array of input images</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandunfold"
              c:identifier="vips_bandunfold"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Unfold image bands into x axis.
Use @factor to set how much to unfold by: @factor 3, for example, will make
the output image three times wider than the input, and with one third
as many bands. By default, all bands are unfolded.

See also: vips_csvload(), vips_bandfold().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="blob_copy"
              c:identifier="vips_blob_copy"
              moved-to="Blob.copy">
      <doc xml:space="preserve">Like vips_blob_new(), but take a copy of the data. Useful for bindings
which strugle with callbacks.

See also: vips_blob_new().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new #VipsBlob.</doc>
        <type name="Blob" c:type="VipsBlob*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">data to store</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes in @data</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="boolean" c:identifier="vips_boolean" introspectable="0">
      <doc xml:space="preserve">Perform various boolean operations on pairs of images.

The output image is the same format as the upcast input images for integer
types. Float types are cast to int before processing. Complex types are not
supported.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="boolean" transfer-ownership="none">
          <doc xml:space="preserve">boolean operation to perform</doc>
          <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="boolean_const"
              c:identifier="vips_boolean_const"
              introspectable="0">
      <doc xml:space="preserve">Perform various boolean operations on an image against an array of
constants.

The output type is always uchar, with 0 for FALSE and 255 for TRUE.

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="boolean" transfer-ownership="none">
          <doc xml:space="preserve">boolean operation to perform</doc>
          <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="boolean_const1"
              c:identifier="vips_boolean_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform various boolean operations on an image with a single constant. See
vips_boolean_const().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="boolean" transfer-ownership="none">
          <doc xml:space="preserve">boolean operation to perform</doc>
          <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="byteswap" c:identifier="vips_byteswap" introspectable="0">
      <doc xml:space="preserve">Swap the byte order in an image.

See also: vips_rawload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cache" c:identifier="vips_cache" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation behaves rather like vips_copy() between images
@in and @out, except that it keeps a cache of computed pixels.
This cache is made of up to @max_tiles tiles (a value of -1
means any number of tiles), and each tile is of size @tile_width
by @tile_height pixels. By default it will cache 250 128 x 128 pixel tiles,
enough for two 1920 x 1080 images.

This operation is a thin wrapper over vips_sink_screen(), see the
documentation for that operation for details.

It uses a set of background threads to calculate pixels and the various
active cache operations coordinate so as not to overwhelm your system. When
a request is made for an area of pixels, the operation will block until all
of those pixels have been calculated. Pixels are calculated with a set of
threads.

See also: vips_tilecache().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_drop_all" c:identifier="vips_cache_drop_all">
      <doc xml:space="preserve">Drop the whole operation cache, handy for leak tracking. Also called
automatically on vips_shutdown().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cache_get_max" c:identifier="vips_cache_get_max">
      <doc xml:space="preserve">Get the maximum number of operations we keep in cache.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the maximum number of operations we keep in cache</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_get_max_files"
              c:identifier="vips_cache_get_max_files">
      <doc xml:space="preserve">Get the maximum number of tracked files we allow before we start dropping
cached operations. See vips_tracked_get_files().

See also: vips_tracked_get_files().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the maximum number of tracked files we allow</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_get_max_mem" c:identifier="vips_cache_get_max_mem">
      <doc xml:space="preserve">Get the maximum amount of tracked memory we allow before we start dropping
cached operations. See vips_tracked_get_mem().

See also: vips_tracked_get_mem().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the maximum amount of tracked memory we allow</doc>
        <type name="gsize" c:type="size_t"/>
      </return-value>
    </function>
    <function name="cache_get_size" c:identifier="vips_cache_get_size">
      <doc xml:space="preserve">Get the current number of operations in cache.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">get the current number of operations in cache.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_operation_add"
              c:identifier="vips_cache_operation_add">
      <doc xml:space="preserve">Add a built operation to the cache. The cache will ref the operation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve">pointer to operation to add</doc>
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_operation_build"
              c:identifier="vips_cache_operation_build">
      <doc xml:space="preserve">A binding-friendly version of vips_cache_operation_buildp().

After calling this, @operation has the same ref count as when it went in,
and the result must be freed with vips_object_unref_outputs() and
g_object_unref().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The built operation.</doc>
        <type name="Operation" c:type="VipsOperation*"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve">operation to lookup</doc>
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_operation_buildp"
              c:identifier="vips_cache_operation_buildp"
              introspectable="0">
      <doc xml:space="preserve">Look up @operation in the cache. If we get a hit, unref @operation, ref the
old one and return that through the argument pointer.

If we miss, build and add @operation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve">pointer to operation to lookup</doc>
          <type name="Operation" c:type="VipsOperation**"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_operation_lookup"
              c:identifier="vips_cache_operation_lookup">
      <doc xml:space="preserve">Look up an unbuilt @operation in the cache. If we get a hit, ref and
return the old operation. If there's no hit, return NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the cache hit, if any.</doc>
        <type name="Operation" c:type="VipsOperation*"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve">pointer to operation to lookup</doc>
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_print" c:identifier="vips_cache_print">
      <doc xml:space="preserve">Print the whole operation cache to stdout. Handy for debugging.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cache_set_dump" c:identifier="vips_cache_set_dump">
      <doc xml:space="preserve">Handy for debugging. Print the operation cache to stdout just before exit.

See also: vips_cache_set_trace().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dump" transfer-ownership="none">
          <doc xml:space="preserve">if %TRUE, dump the operation cache on exit</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max" c:identifier="vips_cache_set_max">
      <doc xml:space="preserve">Set the maximum number of operations we keep in cache.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max" transfer-ownership="none">
          <doc xml:space="preserve">maximum number of operation to cache</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max_files"
              c:identifier="vips_cache_set_max_files">
      <doc xml:space="preserve">Set the maximum number of tracked files we allow before we start dropping
cached operations. See vips_tracked_get_files().

See also: vips_tracked_get_files().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_files" transfer-ownership="none">
          <doc xml:space="preserve">max open files we allow</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max_mem" c:identifier="vips_cache_set_max_mem">
      <doc xml:space="preserve">Set the maximum amount of tracked memory we allow before we start dropping
cached operations. See vips_tracked_get_mem().

See also: vips_tracked_get_mem().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_mem" transfer-ownership="none">
          <doc xml:space="preserve">maximum amount of tracked memory we use</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_trace" c:identifier="vips_cache_set_trace">
      <doc xml:space="preserve">Handy for debugging. Print operation cache actions to stdout as we run.

See also: vips_cache_set_dump().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="trace" transfer-ownership="none">
          <doc xml:space="preserve">if %TRUE, trace the operation cache</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="call" c:identifier="vips_call" introspectable="0">
      <doc xml:space="preserve">vips_call() calls the named operation, passing in required arguments and
then setting any optional ones from the remainder of the arguments as a set
of name/value pairs.

For example, vips_embed() takes six required arguments, @in, @out, @x, @y,
@width, @height, and has two optional arguments, @extend and @background.
You can run it with vips_call() like this:

|[
VipsImage *in = ...
VipsImage *out;

if( vips_call( "embed", in, &amp;amp;out, 10, 10, 100, 100,
	"extend", VIPS_EXTEND_COPY,
	NULL ) )
	... error
]|

Normally of course you'd just use the vips_embed() wrapper function and get
type-safety for the required arguments.

See also: vips_call_split(), vips_call_options().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve">name of operation to call</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">required args, then a %NULL-terminated list of argument/value pairs</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="call_argv" c:identifier="vips_call_argv">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
        <parameter name="argc" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_options" c:identifier="vips_call_options">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="group" transfer-ownership="none">
          <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
        </parameter>
        <parameter name="operation" transfer-ownership="none">
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_required_optional"
              c:identifier="vips_call_required_optional"
              introspectable="0">
      <doc xml:space="preserve">This is the main entry point for the C and C++ varargs APIs. @operation
is executed, supplying @required and @optional arguments.

Beware, this can change @operation to point at an old, cached one.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve">the operation to execute</doc>
          <type name="Operation" c:type="VipsOperation**"/>
        </parameter>
        <parameter name="required" transfer-ownership="none">
          <doc xml:space="preserve">%va_list of required arguments</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="optional" transfer-ownership="none">
          <doc xml:space="preserve">NULL-terminated %va_list of name / value pairs</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_split"
              c:identifier="vips_call_split"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="optional" transfer-ownership="none">
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="call_split_option_string"
              c:identifier="vips_call_split_option_string"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="option_string" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="optional" transfer-ownership="none">
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast" c:identifier="vips_cast" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Convert @in to @format. You can convert between any pair of formats.
Floats are truncated (not rounded). Out of range values are clipped.

Casting from complex to real returns the real part.

If @shift is %TRUE, integer values are shifted up and down. For example,
casting from unsigned 8 bit to unsigned 16 bit would
shift every value left by 8 bits. The bottom bit is copied into the new
bits, so 255 would become 65535.

See also: vips_scale(), vips_complexform(), vips_real(), vips_imag(),
vips_cast_uchar(), vips_msb().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format to convert to</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_char"
              c:identifier="vips_cast_char"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_CHAR. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_complex"
              c:identifier="vips_cast_complex"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_COMPLEX. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_double"
              c:identifier="vips_cast_double"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_DOUBLE. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_dpcomplex"
              c:identifier="vips_cast_dpcomplex"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_DPCOMPLEX. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_float"
              c:identifier="vips_cast_float"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_FLOAT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_int" c:identifier="vips_cast_int" introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_INT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_short"
              c:identifier="vips_cast_short"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_SHORT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_uchar"
              c:identifier="vips_cast_uchar"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_UCHAR. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_uint"
              c:identifier="vips_cast_uint"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_UINT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cast_ushort"
              c:identifier="vips_cast_ushort"
              introspectable="0">
      <doc xml:space="preserve">Convert @in to #VIPS_FORMAT_USHORT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ceil" c:identifier="vips_ceil" introspectable="0">
      <doc xml:space="preserve">Round to an integral value with #VIPS_OPERATION_ROUND_CEIL. See
vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="check_8or16" c:identifier="vips_check_8or16">
      <doc xml:space="preserve">Check that the image is 8 or 16-bit integer, signed or unsigned.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bandno" c:identifier="vips_check_bandno">
      <doc xml:space="preserve">@bandno should be a valid band number (ie. 0 to im-&gt;Bands - 1), or can be
-1, meaning all bands.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bandno" transfer-ownership="none">
          <doc xml:space="preserve">band number</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands" c:identifier="vips_check_bands">
      <doc xml:space="preserve">Check that the image has @bands bands.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:space="preserve">must have this many bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1or3" c:identifier="vips_check_bands_1or3">
      <doc xml:space="preserve">Check that the image has either one or three bands.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1orn" c:identifier="vips_check_bands_1orn">
      <doc xml:space="preserve">Check that the images have the same number of bands, or that one of the
images has just 1 band.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1orn_unary"
              c:identifier="vips_check_bands_1orn_unary">
      <doc xml:space="preserve">Check that an image has 1 or @n bands. Handy for unary operations, cf.
vips_check_bands_1orn().
If not, set an error message
and return non-zero.

See also: vips_check_bands_1orn().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of bands, or 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_atleast"
              c:identifier="vips_check_bands_atleast">
      <doc xml:space="preserve">Check that the image has at least @bands bands.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:space="preserve">at least this many bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_same" c:identifier="vips_check_bands_same">
      <doc xml:space="preserve">Check that the images have the same number of bands.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding" c:identifier="vips_check_coding">
      <doc xml:space="preserve">Check that the image has the required @coding.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="coding" transfer-ownership="none">
          <doc xml:space="preserve">required coding</doc>
          <type name="Coding" c:type="VipsCoding"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_known" c:identifier="vips_check_coding_known">
      <doc xml:space="preserve">Check that the image is uncoded, LABQ coded or RAD coded.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_noneorlabq"
              c:identifier="vips_check_coding_noneorlabq">
      <doc xml:space="preserve">Check that the image is uncoded or LABQ coded.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_same" c:identifier="vips_check_coding_same">
      <doc xml:space="preserve">Check that the images have the same coding.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_complex" c:identifier="vips_check_complex">
      <doc xml:space="preserve">Check that the image is complex.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_format" c:identifier="vips_check_format">
      <doc xml:space="preserve">Check that the image has the specified format.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">format to test for</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_format_same" c:identifier="vips_check_format_same">
      <doc xml:space="preserve">Check that the images have the same format.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_hist" c:identifier="vips_check_hist">
      <doc xml:space="preserve">Histogram images must have width or height 1, and must not have more than
65536 elements. Return 0 if the image will pass as a histogram, or -1 and
set an error message otherwise.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_int" c:identifier="vips_check_int">
      <doc xml:space="preserve">Check that the image is in one of the integer formats.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_matrix" c:identifier="vips_check_matrix">
      <doc xml:space="preserve">Matrix images must have width and height less than 100000 and have 1 band.

Return 0 if the image will pass as a matrix, or -1 and set an error
message otherwise.

@out is set to be @im cast to double and stored in memory. Use
VIPS_MATRIX() to address values in @out.

You must unref @out when you are done with it.

See also: VIPS_MATRIX(), vips_object_local()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">put image as in-memory doubles here</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_mono" c:identifier="vips_check_mono">
      <doc xml:space="preserve">Check that the image has exactly one band.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_noncomplex" c:identifier="vips_check_noncomplex">
      <doc xml:space="preserve">Check that the image is not complex.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_oddsquare" c:identifier="vips_check_oddsquare">
      <doc xml:space="preserve">Check that the image is square and that the sides are odd.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_precision_intfloat"
              c:identifier="vips_check_precision_intfloat">
      <doc xml:space="preserve">Check that @prec image is either float or int.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="precision" transfer-ownership="none">
          <doc xml:space="preserve">precision to check</doc>
          <type name="Precision" c:type="VipsPrecision"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_separable" c:identifier="vips_check_separable">
      <doc xml:space="preserve">Separable matrix images must have width or height 1.
Return 0 if the image will pass, or -1 and
set an error message otherwise.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_size_same" c:identifier="vips_check_size_same">
      <doc xml:space="preserve">Check that the images have the same size.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_twocomponents"
              c:identifier="vips_check_twocomponents">
      <doc xml:space="preserve">Check that the image is has two "components", ie. is a one-band complex or
a two-band non-complex.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_u8or16" c:identifier="vips_check_u8or16">
      <doc xml:space="preserve">Check that the image is 8 or 16-bit unsigned integer.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_u8or16orf" c:identifier="vips_check_u8or16orf">
      <doc xml:space="preserve">Check that the image is 8 or 16-bit unsigned integer, or float.
Otherwise set an error message and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uint" c:identifier="vips_check_uint">
      <doc xml:space="preserve">Check that the image is in one of the unsigned integer formats.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uintorf" c:identifier="vips_check_uintorf">
      <doc xml:space="preserve">Check that the image is unsigned int or float.
Otherwise set an error message and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uncoded" c:identifier="vips_check_uncoded">
      <doc xml:space="preserve">Check that the image is not coded.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_vector" c:identifier="vips_check_vector">
      <doc xml:space="preserve">Operations with a vector constant need a 1-element vector, or a vector with
the same number of elements as there are bands in the image.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in vector</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve">image to check against</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_vector_length"
              c:identifier="vips_check_vector_length">
      <doc xml:space="preserve">Check that @n == @len.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in vector</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">number of elements vector should have</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_find"
              c:identifier="vips_class_find"
              introspectable="0">
      <doc xml:space="preserve">Search below @basename, return the first class whose name or @nickname
matches.

See also: vips_type_find()</doc>
      <return-value>
        <doc xml:space="preserve">the found class.</doc>
        <type name="ObjectClass" c:type="VipsObjectClass*"/>
      </return-value>
      <parameters>
        <parameter name="basename" transfer-ownership="none">
          <doc xml:space="preserve">name of base class</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="nickname" transfer-ownership="none">
          <doc xml:space="preserve">search for a class with this nickname</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_map_all"
              c:identifier="vips_class_map_all"
              introspectable="0">
      <doc xml:space="preserve">Loop over all the subclasses of @type. Non-abstract classes only.
Stop when @fn returns
non-%NULL and return that value.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first
non-%NULL value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:space="preserve">call this function for every type</doc>
          <type name="ClassMapFn" c:type="VipsClassMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_C2Ccmc" c:identifier="vips_col_C2Ccmc">
      <doc xml:space="preserve">Calculate Ccmc from C.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Ccmc.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Ccmc2C" c:identifier="vips_col_Ccmc2C">
      <doc xml:space="preserve">Calculate C from Ccmc using a table.
Call vips_col_make_tables_CMC() at
least once before using this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">C.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="Ccmc" transfer-ownership="none">
          <doc xml:space="preserve">Ccmc</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Ch2ab" c:identifier="vips_col_Ch2ab">
      <doc xml:space="preserve">Calculate ab from Ch, h in degrees.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <doc xml:space="preserve">Hue angle (degrees)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">return CIE a* value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">return CIE b* value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Ch2hcmc" c:identifier="vips_col_Ch2hcmc">
      <doc xml:space="preserve">Calculate hcmc from C and h.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">hcmc.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <doc xml:space="preserve">Hue (degrees)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Chcmc2h" c:identifier="vips_col_Chcmc2h">
      <doc xml:space="preserve">Calculate h from C and hcmc, using a table.
Call vips_col_make_tables_CMC() at
least once before using this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">h.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="hcmc" transfer-ownership="none">
          <doc xml:space="preserve">Hue cmc (degrees)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_L2Lcmc" c:identifier="vips_col_L2Lcmc">
      <doc xml:space="preserve">Calculate Lcmc from L.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Lcmc</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="L" transfer-ownership="none">
          <doc xml:space="preserve">CIE L*</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Lab2XYZ" c:identifier="vips_col_Lab2XYZ">
      <doc xml:space="preserve">Calculate XYZ from Lab, D65.

See also: vips_Lab2XYZ().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="L" transfer-ownership="none">
          <doc xml:space="preserve">Input CIE Lab value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">Input CIE Lab value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">Input CIE Lab value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="X" transfer-ownership="none">
          <doc xml:space="preserve">Return CIE XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Y" transfer-ownership="none">
          <doc xml:space="preserve">Return CIE XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Z" transfer-ownership="none">
          <doc xml:space="preserve">Return CIE XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Lcmc2L" c:identifier="vips_col_Lcmc2L">
      <doc xml:space="preserve">Calculate L from Lcmc using a table. Call vips_col_make_tables_CMC() at
least once before using this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">L*</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="Lcmc" transfer-ownership="none">
          <doc xml:space="preserve">L cmc</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_XYZ2Lab" c:identifier="vips_col_XYZ2Lab">
      <doc xml:space="preserve">Calculate XYZ from Lab, D65.

See also: vips_XYZ2Lab().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="X" transfer-ownership="none">
          <doc xml:space="preserve">Input CIE XYZ colour</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Y" transfer-ownership="none">
          <doc xml:space="preserve">Input CIE XYZ colour</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Z" transfer-ownership="none">
          <doc xml:space="preserve">Input CIE XYZ colour</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="L" transfer-ownership="none">
          <doc xml:space="preserve">Return CIE Lab value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">Return CIE Lab value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">Return CIE Lab value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_XYZ2scRGB" c:identifier="vips_col_XYZ2scRGB">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="X" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Y" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Z" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_ab2Ch" c:identifier="vips_col_ab2Ch">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="C" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_ab2h" c:identifier="vips_col_ab2h">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Hue (degrees)</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">CIE a</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">CIE b</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_dE00" c:identifier="vips_col_dE00">
      <doc xml:space="preserve">CIEDE2000, from:

Luo, Cui, Rigg, "The Development of the CIE 2000 Colour-Difference
Formula: CIEDE2000", COLOR research and application, pp 340</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">CIE dE2000 colour difference.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="L1" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a1" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b1" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="L2" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a2" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b2" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_make_tables_CMC"
              c:identifier="vips_col_make_tables_CMC">
      <doc xml:space="preserve">Make the lookup tables for cmc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="col_sRGB2scRGB_16" c:identifier="vips_col_sRGB2scRGB_16">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_sRGB2scRGB_8" c:identifier="vips_col_sRGB2scRGB_8">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2BW_16" c:identifier="vips_col_scRGB2BW_16">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2BW_8" c:identifier="vips_col_scRGB2BW_8">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2XYZ" c:identifier="vips_col_scRGB2XYZ">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="X" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Y" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Z" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2sRGB_16" c:identifier="vips_col_scRGB2sRGB_16">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2sRGB_8" c:identifier="vips_col_scRGB2sRGB_8">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="colourspace"
              c:identifier="vips_colourspace"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation looks at the interpretation field of @in (or uses
@source_space, if set) and runs
a set of colourspace conversion functions to move it to @space.

For example, given an image tagged as #VIPS_INTERPRETATION_YXY, running
vips_colourspace() with @space set to #VIPS_INTERPRETATION_LAB will
convert with vips_Yxy2XYZ() and vips_XYZ2Lab().

See also: vips_colourspace_issupported(),
vips_image_guess_interpretation().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="space" transfer-ownership="none">
          <doc xml:space="preserve">convert to this colour space</doc>
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="colourspace_issupported"
              c:identifier="vips_colourspace_issupported">
      <doc xml:space="preserve">Test if @image is in a colourspace that vips_colourspace() can process. For
example, #VIPS_INTERPRETATION_RGB images are not in a well-defined
colourspace, but #VIPS_INTERPRETATION_sRGB ones are.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @image is in a supported colourspace.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="const VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="compass" c:identifier="vips_compass" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="complex" c:identifier="vips_complex" introspectable="0">
      <doc xml:space="preserve">Perform various operations on complex images.

Angles are expressed in degrees. The output type is complex unless the
input is double or dpcomplex, in which case the output is dpcomplex.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="cmplx" transfer-ownership="none">
          <doc xml:space="preserve">complex operation to perform</doc>
          <type name="OperationComplex" c:type="VipsOperationComplex"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="complex2" c:identifier="vips_complex2" introspectable="0">
      <doc xml:space="preserve">Perform various binary operations on complex images.

Angles are expressed in degrees. The output type is complex unless the
input is double or dpcomplex, in which case the output is dpcomplex.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="cmplx" transfer-ownership="none">
          <doc xml:space="preserve">complex2 operation to perform</doc>
          <type name="OperationComplex2" c:type="VipsOperationComplex2"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="complexform"
              c:identifier="vips_complexform"
              introspectable="0">
      <doc xml:space="preserve">Compose two real images to make a complex image. If either @left or @right
are #VIPS_FORMAT_DOUBLE, @out is #VIPS_FORMAT_DPCOMPLEX. Otherwise @out
is #VIPS_FORMAT_COMPLEX. @left becomes the real component of @out and
@right the imaginary.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

See also: vips_complexget().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="complexget"
              c:identifier="vips_complexget"
              introspectable="0">
      <doc xml:space="preserve">Get components of complex images.

The output type is the same as the input type, except #VIPS_FORMAT_COMPLEX
becomes #VIPS_FORMAT_FLOAT and #VIPS_FORMAT_DPCOMPLEX becomes
#VIPS_FORMAT_DOUBLE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="get" transfer-ownership="none">
          <doc xml:space="preserve">complex operation to perform</doc>
          <type name="OperationComplexget" c:type="VipsOperationComplexget"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="conj" c:identifier="vips_conj" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_COMPLEX_CONJ on an image. See vips_complex().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="conv" c:identifier="vips_conv" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Convolution.

Perform a convolution of @in with @mask.
Each output pixel is
calculated as sigma[i]{pixel[i] * mask[i]} / scale + offset, where scale
and offset are part of @mask.

If @precision is #VIPS_PRECISION_INTEGER then the convolution is performed
with integer arithmetic and the output image
always has the same #VipsBandFormat as the input image.

Convolutions on unsigned 8-bit images are calculated with the
processor's vector unit, if possible. Disable this with --vips-novector or
IM_NOVECTOR.

If @precision is #VIPS_PRECISION_FLOAT then the convolution is performed
with floating-point arithmetic. The output image
is always %VIPS_FORMAT_FLOAT unless @in is %VIPS_FORMAT_DOUBLE, in which case
@out is also %VIPS_FORMAT_DOUBLE.

If @precision is #VIPS_PRECISION_APPROXIMATE then the output image
always has the same #VipsBandFormat as the input image.

Larger values for @layers give more accurate
results, but are slower. As @layers approaches the mask radius, the
accuracy will become close to exact convolution and the speed will drop to
match. For many large masks, such as Gaussian, @n_layers need be only 10% of
this value and accuracy will still be good.

Smaller values of @cluster will give more accurate results, but be slower
and use more memory. 10% of the mask radius is a good rule of thumb.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">convolve with this mask</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="convsep" c:identifier="vips_convsep" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Perform a separable convolution of @in with @mask.
See vips_conv() for a detailed description.

The mask must be 1xn or nx1 elements.

The image is convolved twice: once with @mask and then again with @mask
rotated by 90 degrees. This is much faster for certain types of mask
(gaussian blur, for example) than doing a full 2D convolution.

See also: vips_conv(), vips_gaussmat().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">convolution mask</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="copy" c:identifier="vips_copy" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Copy an image, optionally modifying the header. VIPS copies images by
copying pointers, so this operation is instant, even for very large images.

You can optionally change any or all header fields during the copy. You can
make any change which does not change the size of a pel, so for example
you can turn a 4-band uchar image into a 2-band ushort image, but you
cannot change a 100 x 100 RGB image into a 300 x 100 mono image.

See also: vips_byteswap(), vips_bandfold(), vips_bandunfold().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="copy_file"
              c:identifier="vips_copy_file"
              introspectable="0">
      <doc xml:space="preserve">A simple convenience function to copy an image to a file, then copy
again to output. If the image is already a file, just copy straight
through.

The file is allocated with vips_image_new_temp_file().
The file is automatically deleted when @out is closed.

See also: vips_copy(), vips_image_new_temp_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cos" c:identifier="vips_cos" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_COS on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="countlines"
              c:identifier="vips_countlines"
              introspectable="0">
      <doc xml:space="preserve">Function which calculates the number of transitions
between black and white for the horizontal or the vertical
direction of an image.  black&lt;128 , white&gt;=128
The function calculates the number of transitions for all
Xsize or Ysize and returns the mean of the result
Input should be one band, 8-bit.

See also: vips_morph(), vips_conv().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="nolines" transfer-ownership="none">
          <doc xml:space="preserve">output average number of lines</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">count lines horizontally or vertically</doc>
          <type name="Direction" c:type="VipsDirection"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="crop" c:identifier="vips_crop" introspectable="0">
      <doc xml:space="preserve">A synonym for vips_extract_area().

See also: vips_extract_bands().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left edge of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">top edge of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">width of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">height of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="cross_phase"
              c:identifier="vips_cross_phase"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_COMPLEX2_CROSS_PHASE on an image.
See vips_complex2().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="csvload" c:identifier="vips_csvload" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Load a CSV (comma-separated values) file. The output image is always 1
band (monochrome), #VIPS_FORMAT_DOUBLE. Use vips_bandfold() to turn
RGBRGBRGB mono images into colour iamges.

Items in lines can be either floating point numbers in the C locale, or
strings enclosed in double-quotes ("), or empty.
You can use a backslash (\) within the quotes to escape special characters,
such as quote marks.

The reader is deliberately rather fussy: it will fail if there are any
short lines, or if the file is too short. It will ignore lines that are
too long.

@skip sets the number of lines to skip at the start of the file.
Default zero.

@lines sets the number of lines to read from the file. Default -1,
meaning read all lines to end of file.

@whitespace sets the skippable whitespace characters.
Default &lt;emphasis&gt;space&lt;/emphasis&gt;.
Whitespace characters are always run together.

@separator sets the characters that separate fields.
Default ;,&lt;emphasis&gt;tab&lt;/emphasis&gt;. Separators are never run together.

See also: vips_image_new_from_file(), vips_bandfold().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="csvsave" c:identifier="vips_csvsave" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Writes the pixels in @in to the @filename as CSV (comma-separated values).
The image is written
one line of text per scanline. Complex numbers are written as
"(real,imaginary)" and will need extra parsing I guess. Only the first band
is written.

@separator gives the string to use to separate numbers in the output.
The default is "\\t" (tab).

See also: vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dE00" c:identifier="vips_dE00" introspectable="0">
      <doc xml:space="preserve">Calculate dE 00.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">first input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">second input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dE76" c:identifier="vips_dE76" introspectable="0">
      <doc xml:space="preserve">Calculate dE 76.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">first input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">second input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dECMC" c:identifier="vips_dECMC" introspectable="0">
      <doc xml:space="preserve">Calculate dE CMC. The input images are transformed to CMC colour space and
the euclidean distance between corresponding pixels calculated.

To calculate a colour difference with values for (l:c) other than (1:1),
transform the two source images to CMC yourself, scale the channels
appropriately, and call this function.

See also: vips_colourspace()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">first input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">second input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="deviate" c:identifier="vips_deviate" introspectable="0">
      <doc xml:space="preserve">This operation finds the standard deviation of all pixels in @in. It
operates on all bands of the input image: use vips_stats() if you need
to calculate an average for each band.

Non-complex images only.

See also: vips_avg(), vips_stats()..</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output pixel standard deviation</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="divide" c:identifier="vips_divide" introspectable="0">
      <doc xml:space="preserve">This operation calculates @in1 / @in2 and writes the result to @out. If any
pixels in @in2 are zero, the corresponding pixel in @out is also zero.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;), then the
following table is used to determine the output type:

&lt;table&gt;
  &lt;title&gt;vips_divide() type promotion&lt;/title&gt;
  &lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
    &lt;thead&gt;
      &lt;row&gt;
        &lt;entry&gt;input type&lt;/entry&gt;
        &lt;entry&gt;output type&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;uchar&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;char&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;ushort&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;short&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;int&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;float&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double&lt;/entry&gt;
        &lt;entry&gt;double&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_multiply(), vips_linear(), vips_pow().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_circle"
              c:identifier="vips_draw_circle"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Draws a circle on @image. If @fill is %TRUE then the circle is filled,
otherwise a 1-pixel-wide perimeter is drawn.

@ink is an array of double containing values to draw.

See also: vips_draw_circle1(), vips_draw_line().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">length of ink array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="cx" transfer-ownership="none">
          <doc xml:space="preserve">centre of draw_circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="cy" transfer-ownership="none">
          <doc xml:space="preserve">centre of draw_circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <doc xml:space="preserve">draw_circle radius</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_circle1"
              c:identifier="vips_draw_circle1"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

As vips_draw_circle(), but just takes a single double for @ink.

See also: vips_draw_circle().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="cx" transfer-ownership="none">
          <doc xml:space="preserve">centre of draw_circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="cy" transfer-ownership="none">
          <doc xml:space="preserve">centre of draw_circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <doc xml:space="preserve">draw_circle radius</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_flood"
              c:identifier="vips_draw_flood"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Flood-fill @image with @ink, starting at position @x, @y. The filled area is
bounded by pixels that are equal to the ink colour, in other words, it
searches for pixels enclosed by an edge of @ink.

If @equal is set, it instead searches for pixels which are equal to the
start point and fills them with @ink.

Normally it will test and set pixels in @image. If @test is set, it will
test pixels in @test and set pixels in @image. This lets you search an
image (@test) for continuous areas of pixels without modifying it.

@left, @top, @width, @height output the bounding box of the modified
pixels.

@ink is an array of double containing values to draw.

See also: vips_draw_flood1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">length of ink array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">centre of circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">centre of circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_flood1"
              c:identifier="vips_draw_flood1"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

As vips_draw_flood(), but just takes a single double for @ink.

See also: vips_draw_flood().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">centre of circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">centre of circle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_image"
              c:identifier="vips_draw_image"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Draw @sub on top of @image at position @x, @y. The two images must have the
same Coding. If @sub has 1 band, the bands will be duplicated to match the
number of bands in @image. @sub will be converted to @image's format, see
vips_cast().

Use @mode to set how pixels are combined. If you use
#VIPS_COMBINE_MODE_ADD, both images muct be uncoded.

See also: vips_draw_mask(), vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="sub" transfer-ownership="none">
          <doc xml:space="preserve">image to paint</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">draw @sub here</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">draw @sub here</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_line"
              c:identifier="vips_draw_line"
              introspectable="0">
      <doc xml:space="preserve">Draws a 1-pixel-wide line on an image.

@ink is an array of double containing values to draw.

See also: vips_draw_line1(), vips_draw_circle(), vips_draw_mask().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">length of ink array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve">start of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve">start of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:space="preserve">end of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:space="preserve">end of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_line1"
              c:identifier="vips_draw_line1"
              introspectable="0">
      <doc xml:space="preserve">As vips_draw_line(), but just take a single double for @ink.

See also: vips_draw_line().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve">start of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve">start of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:space="preserve">end of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:space="preserve">end of draw_line</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_mask"
              c:identifier="vips_draw_mask"
              introspectable="0">
      <doc xml:space="preserve">Draw @mask on the image. @mask is a monochrome 8-bit image with 0/255
for transparent or @ink coloured points. Intermediate values blend the ink
with the pixel. Use with vips_text() to draw text on an image. Use in a
vips_draw_line() subclass to draw an object along a line.

@ink is an array of double containing values to draw.

See also: vips_text(), vips_draw_line().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">size of ink array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">mask of 0/255 values showing where to plot</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">draw mask here</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">draw mask here</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_mask1"
              c:identifier="vips_draw_mask1"
              introspectable="0">
      <doc xml:space="preserve">As vips_draw_mask(), but just takes a single double for @ink.

See also: vips_draw_mask().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">mask of 0/255 values showing where to plot</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">draw mask here</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">draw mask here</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_point"
              c:identifier="vips_draw_point"
              introspectable="0">
      <doc xml:space="preserve">As vips_draw_rect(), but draw a single pixel at @x, @y.

See also: vips_draw_rect().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">length of ink array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">point to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">point to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_point1"
              c:identifier="vips_draw_point1"
              introspectable="0">
      <doc xml:space="preserve">As vips_draw_point(), but just take a single double for @ink.

See also: vips_draw_point().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">point to draw</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">point to draw</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_rect"
              c:identifier="vips_draw_rect"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Paint pixels within @left, @top, @width, @height in @image with @ink. If
@fill is zero, just paint a 1-pixel-wide outline.

See also: vips_draw_circle().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">length of ink array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_rect1"
              c:identifier="vips_draw_rect1"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

As vips_draw_rect(), but just take a single double for @ink.

See also: vips_draw_rect().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ink" transfer-ownership="none">
          <doc xml:space="preserve">value to draw</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_smudge"
              c:identifier="vips_draw_smudge"
              introspectable="0">
      <doc xml:space="preserve">Smudge a section of @image. Each pixel in the area @left, @top, @width,
@height is replaced by the average of the surrounding 3x3 pixels.

See also: vips_draw_line().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <doc xml:space="preserve">image to draw on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">point to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">point to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">area to paint</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dzsave" c:identifier="vips_dzsave" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

@layout; directory layout convention
Save an image as a set of tiles at various resolutions. By default dzsave
uses DeepZoom layout -- use @layout to pick other conventions.

vips_dzsave() creates a directory called @name to hold the tiles. If @name
ends `.zip`, vips_dzsave() will create a zip file called @name to hold the
tiles.  You can use @container to force zip file output.

You can set @suffix to something like `".jpg[Q=85]"` to control the tile
write options.

In Google layout mode, edge tiles are expanded to @tile_size by @tile_size
pixels. Normally they are filled with white, but you can set another colour
with @background. Images are usually placed at the top-left of the tile,
but you can have them centred by turning on @centre.

You can set the size and overlap of tiles with @tile_size and @overlap.
They default to the correct settings for the selected @layout. The deepzoom
defaults produce 256x256 jpeg files for centre tiles, the most efficient
size.

Use @depth to control how low the pyramid goes. This defaults to the
correct setting for the @layout you select.

If @properties is %TRUE, vips_dzsave() will write a file called
`vips-properties.xml` to the output directory. This file lists all of the
metadata attached to @in in an obvious manner. It can be useful for viewing
programs which wish to use fields from source files loaded via
vips_openslideload().

See also: vips_tiffsave().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name to save to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="embed" c:identifier="vips_embed" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

The opposite of vips_extract_area(): embed @in within an image of size
@width by @height at position @x, @y.

@extend
controls what appears in the new pels, see #VipsExtend.

See also: vips_extract_area(), vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">place @in at this x position in @out</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">place @in at this y position in @out</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">@out should be this many pixels across</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">@out should be this many pixels down</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="eorimage" c:identifier="vips_eorimage" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_EOR on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="eorimage_const"
              c:identifier="vips_eorimage_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_EOR on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="eorimage_const1"
              c:identifier="vips_eorimage_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_EOR on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="equal" c:identifier="vips_equal" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_EQUAL on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="equal_const"
              c:identifier="vips_equal_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_EQUAL on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="equal_const1"
              c:identifier="vips_equal_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_EQUAL on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="error" c:identifier="vips_error" introspectable="0">
      <doc xml:space="preserve">Format the string in the style of printf() and append to the error buffer.

See also: vips_error_system(), vips_verror().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="error_buffer" c:identifier="vips_error_buffer">
      <doc xml:space="preserve">Get a pointer to the start of the error buffer as a C string.
The string is owned by the error system and must not be freed.

See also: vips_error_clear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error buffer as a C string which must not be freed</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="error_clear" c:identifier="vips_error_clear">
      <doc xml:space="preserve">Clear and reset the error buffer. This is typically called after presenting
an error to the user.

See also: vips_error_buffer().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_exit"
              c:identifier="vips_error_exit"
              introspectable="0">
      <doc xml:space="preserve">Sends a formatted error message to stderr, then sends the contents of the
error buffer, if any, then shuts down vips and terminates the program with
an error code.

@fmt may be %NULL, in which case only the error buffer is printed before
exiting.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="error_freeze" c:identifier="vips_error_freeze">
      <doc xml:space="preserve">Stop errors being logged. Use vips_error_thaw() to unfreeze. You can
nest freeze/thaw pairs.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_g" c:identifier="vips_error_g" throws="1">
      <doc xml:space="preserve">This function sets the glib error pointer from the vips error buffer and
clears it. It's handy for returning errors to glib functions from vips.

See vips_g_error() for the inverse operation.

See also: g_set_error(), vips_g_error().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_system"
              c:identifier="vips_error_system"
              introspectable="0">
      <doc xml:space="preserve">Format the string in the style of printf() and append to the error buffer.
Then create and append a localised message based on the system error code,
usually the value of errno.

See also: vips_verror_system().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" transfer-ownership="none">
          <doc xml:space="preserve">the system error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="error_thaw" c:identifier="vips_error_thaw">
      <doc xml:space="preserve">Reenable error logging.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="exp" c:identifier="vips_exp" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_EXP on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="exp10" c:identifier="vips_exp10" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_EXP10 on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="extract_area"
              c:identifier="vips_extract_area"
              introspectable="0">
      <doc xml:space="preserve">Extract an area from an image. The area must fit within @in.

See also: vips_extract_bands().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left edge of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">top edge of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">width of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">height of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="extract_band"
              c:identifier="vips_extract_band"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Extract a band or bands from an image. Extracting out of range is an error.

See also: vips_extract_area().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:space="preserve">band to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="falsecolour"
              c:identifier="vips_falsecolour"
              introspectable="0">
      <doc xml:space="preserve">Force @in to 1 band, 8-bit, then transform to
a 3-band 8-bit image with a false colour
map. The map is supposed to make small differences in brightness more
obvious.

See also: vips_maplut().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="fastcor" c:identifier="vips_fastcor" introspectable="0">
      <doc xml:space="preserve">Calculate a fast correlation surface.

@ref is placed at every position in @in and the sum of squares of
differences calculated.

The output
image is the same size as the input. Extra input edge pixels are made by
copying the existing edges outwards.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The output type is uint if both inputs are integer, float if both are float
or complex, and double if either is double or double complex.
In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_spcor().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ref" transfer-ownership="none">
          <doc xml:space="preserve">reference image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_get_filename"
              c:identifier="vips_filename_get_filename">
      <doc xml:space="preserve">Given a vips filename like "fred.jpg[Q=90]", return a new string of
just the filename part, "fred.jpg" in this case.

Useful for language bindings.

See also: vips_filename_get_options().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">transfer full: just the filename component.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="vips_filename" transfer-ownership="none">
          <doc xml:space="preserve">a filename including a set of options</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_get_options"
              c:identifier="vips_filename_get_options">
      <doc xml:space="preserve">Given a vips filename like "fred.jpg[Q=90]", return a new string of
just the options part, "[Q=90]" in this case.

Useful for language bindings.

See also: vips_filename_get_filename().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">transfer full: just the options component.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="vips_filename" transfer-ownership="none">
          <doc xml:space="preserve">a filename including a set of options</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="fitsload" c:identifier="vips_fitsload" introspectable="0">
      <doc xml:space="preserve">Read a FITS image file into a VIPS image.

This operation can read images with up to three dimensions. Any higher
dimensions must be empty.

It can read 8, 16 and 32-bit integer images, signed and unsigned, float and
double.

FITS metadata is attached with the "fits-" prefix.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="fitssave" c:identifier="vips_fitssave" introspectable="0">
      <doc xml:space="preserve">Write a VIPS image to a file in FITS format.

See also: vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="flatten" c:identifier="vips_flatten" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Take the last band of @in as an alpha and use it to blend the
remaining channels with @background.

The alpha channel is 0 - @max_alpha,
where 1 means 100% image and 0
means 100% background.
Non-complex images only.
@background defaults to zero (black).

@max_alpha has the default value 255. You will need to set this to 65535
for images with a 16-bit alpha, or perhaps 1.0 for images with a float
alpha.

Useful for flattening PNG images to RGB.

See also: vips_premultiply(), vips_pngload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="flip" c:identifier="vips_flip" introspectable="0">
      <doc xml:space="preserve">Flips an image left-right or up-down.

See also: vips_rot().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">flip horizontally or vertically</doc>
          <type name="Direction" c:type="VipsDirection"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="float2rad"
              c:identifier="vips_float2rad"
              introspectable="0">
      <doc xml:space="preserve">Convert a three-band float image to Radiance 32-bit packed format.

See also: vips_rad2float(), #VIPS_CODING_RAD, vips_LabQ2Lab().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="floor" c:identifier="vips_floor" introspectable="0">
      <doc xml:space="preserve">Round to an integral value with #VIPS_OPERATION_ROUND_FLOOR. See
vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="foreign_flags" c:identifier="vips_foreign_flags">
      <doc xml:space="preserve">Return the flags for @filename using @loader.
@loader is something like "tiffload" or "VipsForeignLoadTiff".</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the flags for @filename.</doc>
        <type name="ForeignFlags" c:type="VipsForeignFlags"/>
      </return-value>
      <parameters>
        <parameter name="loader" transfer-ownership="none">
          <doc xml:space="preserve">name of loader to use for test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_sizeof" c:identifier="vips_format_sizeof">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of bytes for a band format.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format type</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="free" c:identifier="vips_free">
      <doc xml:space="preserve">Frees memory with g_free() and returns 0. Handy for callbacks.

See also: vips_malloc().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">memory to free</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_error" c:identifier="vips_g_error" throws="1">
      <doc xml:space="preserve">This function adds the %GError to the vips error buffer and clears it. It's
the opposite of vips_error_g().

See also: vips_error_g().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="gamma" c:identifier="vips_gamma" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Calculate @in ** (1 / @exponent), normalising to the maximum range of the
input type. For float types use 1.0 as the maximum.

See also: vips_identity(), vips_pow_const1(), vips_maplut()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="gaussblur"
              c:identifier="vips_gaussblur"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operator runs vips_gaussmat() and vips_convsep() for you on an image.
Set @min_ampl smaller to generate a larger, more accurate mask. Set @sigma
larger to make the blur more blurry.

See also: vips_gaussmat(), vips_convsep().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="sigma" transfer-ownership="none">
          <doc xml:space="preserve">how large a mask to use</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="get_argv0" c:identifier="vips_get_argv0">
      <doc xml:space="preserve">See also: VIPS_INIT().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a pointer to an internal copy of the argv0 string passed to
VIPS_INIT(). Do not free this value</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="get_disc_threshold" c:identifier="vips_get_disc_threshold">
      <doc xml:space="preserve">Return the number of bytes at which we flip between open via memory and
open via disc. This defaults to 100mb, but can be changed with the
VIPS_DISC_THRESHOLD environment variable or the --vips-disc-threshold
command-line flag. See vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">disc threshold in bytes.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
    </function>
    <function name="getpoint" c:identifier="vips_getpoint" introspectable="0">
      <doc xml:space="preserve">Reads a single pixel on an image.

The pixel values are returned in @vector, the length of the
array in @n. You must free the array with g_free() when you are done with
it.

See also: vips_draw_point().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to read from</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve">array length=n: output pixel value here</doc>
          <type name="gdouble" c:type="double**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">length of output vector</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">position to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">position to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="grid" c:identifier="vips_grid" introspectable="0">
      <doc xml:space="preserve">Chop a tall thin image up into a set of tiles, lay the tiles out in a grid.

The input image should be a very tall, thin image containing a list of
smaller images. Volumetric or time-sequence images are often laid out like
this. This image is chopped into a series of tiles, each @tile_height
pixels high and the width of @in. The tiles are then rearranged into a grid
@across tiles across and @down tiles down in row-major order.

Supplying @tile_height, @across and @down is not strictly necessary, we
only really need two of these. Requiring three is a double-check that the
image has the expected geometry.

See also: vips_embed(), vips_insert(), vips_join().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="tile_height" transfer-ownership="none">
          <doc xml:space="preserve">chop into tiles this high</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="across" transfer-ownership="none">
          <doc xml:space="preserve">tiles across</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="down" transfer-ownership="none">
          <doc xml:space="preserve">tiles down</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="guess_libdir" c:identifier="vips_guess_libdir">
      <doc xml:space="preserve">vips_guess_libdir() tries to guess the install directory (usually the
configure libdir, or $prefix/lib). You should pass
in the value of argv[0] (the name your program was run as) as a clue to
help it out, plus the name of the environment variable you let the user
override your package install area with (eg. "VIPSHOME").

On success, vips_guess_libdir() returns the libdir it discovered, and as a
side effect, sets the prefix environment variable (if it's not set).

Don't free the return string!

See also: vips_guess_prefix().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the libdir as a static string, do not free.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:space="preserve">program name (typically argv[0])</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="env_name" transfer-ownership="none">
          <doc xml:space="preserve">save prefix in this environment variable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="guess_prefix" c:identifier="vips_guess_prefix">
      <doc xml:space="preserve">vips_guess_prefix() tries to guess the install directory. You should pass
in the value of argv[0] (the name your program was run as) as a clue to
help it out, plus the name of the environment variable you let the user
override your package install area with (eg. "VIPSHOME").

On success, vips_guess_prefix() returns the prefix it discovered, and as a
side effect, sets the environment variable (if it's not set).

Don't free the return string!

See also: vips_guess_libdir().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the install prefix as a static string, do not free.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:space="preserve">program name (typically argv[0])</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="env_name" transfer-ownership="none">
          <doc xml:space="preserve">save prefix in this environment variable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hist_find"
              c:identifier="vips_hist_find"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Find the histogram of @in. Find the histogram for band @band (producing a
one-band histogram), or for all bands (producing an n-band histogram) if
@band is -1.

@in is cast to u8 or u16. @out is always u32.

See also: vips_hist_find_ndim(), vips_hist_find_indexed().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="hist_find_indexed"
              c:identifier="vips_hist_find_indexed"
              introspectable="0">
      <doc xml:space="preserve">Make a histogram of @in, but use image @index to pick the bins. In other
words, element zero in @out contains the sum of all the pixels in @in
whose corresponding pixel in @index is zero.

@index must have just one band and be u8 or u16. @in must be
non-complex. @out always has the same size and format as @in.

This operation is useful in conjunction with vips_labelregions(). You can
use it to find the centre of gravity of blobs in an image, for example.

See also: vips_hist_find(), vips_labelregions().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="index" transfer-ownership="none">
          <doc xml:space="preserve">input index image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="hist_find_ndim"
              c:identifier="vips_hist_find_ndim"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Make a one, two or three dimensional histogram of a 1, 2 or
3 band image. Divide each axis into @bins bins .. ie.
output is 1 x bins, bins x bins, or bins x bins x bins bands.
@bins defaults to 10.

Images are cast to uchar or ushort before histogramming.

See also: vips_hist_find(), vips_hist_find_indexed().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="hough_circle"
              c:identifier="vips_hough_circle"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Find the circular Hough transform of an image. @in must be one band, with
non-zero pixels for image edges. @out is three-band, with the third channel
representing the detected circle radius. The operation scales the number of
votes by circle circumference so circles of differing size are given equal
weight.

Use @max_radius and @min_radius to set the range of radii to search for.

Use @scale to set how @in coordinates are scaled to @out coordinates. A
@scale of 3, for example, will make @out 1/3rd of the width and height of
@in, and reduce the number of radii tested (and hence the number of bands
int @out) by a factor of three as well.

See also: vips_hough_line().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="hough_line"
              c:identifier="vips_hough_line"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Find the line Hough transform for @in. @in must have one band. @out has one
band, with pixels being the number of votes for that line. The X dimension
of @out is the line angle, the Y dimension is the distance of the line from
the origin.

Use @width @height to set the size of the parameter space image (@out),
that is, how accurate the line determination should be.

See also: vips_hough_circle().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="icc_ac2rc" c:identifier="vips_icc_ac2rc">
      <doc xml:space="preserve">Transform an image from absolute to relative colorimetry using the
MediaWhitePoint stored in the ICC profile.

See also: vips_icc_transform(), vips_icc_import().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="profile_filename" transfer-ownership="none">
          <doc xml:space="preserve">use this profile</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="icc_export"
              c:identifier="vips_icc_export"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Export an image from D65 LAB to device space with an ICC profile.
If @pcs is
set to #VIPS_PCS_XYZ, use CIE XYZ PCS instead.
If @output_profile is not set, use the embedded profile, if any.
If @output_profile is set, export with that and attach it to the output
image.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="icc_import"
              c:identifier="vips_icc_import"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Import an image from device space to D65 LAB with an ICC profile. If @pcs is
set to #VIPS_PCS_XYZ, use CIE XYZ PCS instead.

If @embedded is set, the input profile is taken from the input image
metadata. If there is no embedded profile,
@input_profile_filename is used as a fall-back.

If @embedded is not set, the input profile is taken from
@input_profile. If @input_profile is not supplied, the
metadata profile, if any, is used as a fall-back.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="icc_present" c:identifier="vips_icc_present">
      <doc xml:space="preserve">VIPS can optionally be built without the ICC library. Use this function to
test for its availability.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">non-zero if the ICC library is present.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="icc_transform"
              c:identifier="vips_icc_transform"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Transform an image with a pair of ICC profiles. The input image is moved to
profile-connection space with the input profile and then to the output
space with the output profile.

If @embedded is set, the input profile is taken from the input image
metadata, if present. If there is no embedded profile,
@input_profile is used as a fall-back.

If @embedded is not set, the input profile is taken from
@input_profile. If @input_profile is not supplied, the
metadata profile, if any, is used as a fall-back.

Use vips_icc_import() and vips_icc_export() to do either the first or
second half of this operation in isolation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="output_profile" transfer-ownership="none">
          <doc xml:space="preserve">get the output profile from here</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ifthenelse"
              c:identifier="vips_ifthenelse"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation scans the condition image @cond
and uses it to select pixels from either the then image @in1 or the else
image @in2. Non-zero means @in1, 0 means @in2.

Any image can have either 1 band or n bands, where n is the same for all
the non-1-band images. Single band images are then effectively copied to
make n-band images.

Images @in1 and @in2 are cast up to the smallest common format. @cond is
cast to uchar.

If the images differ in size, the smaller images are enlarged to match the
largest by adding zero pixels along the bottom and right.

If @blend is %TRUE, then values in @out are smoothly blended between @in1
and @in2 using the formula:

  @out = (@cond / 255) * @in1 + (1 - @cond / 255) * @in2

See also: vips_equal().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="cond" transfer-ownership="none">
          <doc xml:space="preserve">condition #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in1" transfer-ownership="none">
          <doc xml:space="preserve">then #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in2" transfer-ownership="none">
          <doc xml:space="preserve">else #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="imag" c:identifier="vips_imag" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_COMPLEXGET_IMAG on an image. See vips_complexget().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="info" c:identifier="vips_info" introspectable="0">
      <doc xml:space="preserve">Sends a formatted informational message to stderr if the --vips-info flag
has been given to the program or the environment variable VIPS_INFO has been
defined, or if vips_info_set() has been called.

Informational messages are used to report details about the operation of
functions.

See also: vips_info_set(), vips_vinfo(), vips_warn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the diagnostic message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="info_set" c:identifier="vips_info_set">
      <doc xml:space="preserve">If set, vips will output various informative messages to stderr as it works.

See also: vips_info().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to enable info messages</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="vips_init">
      <doc xml:space="preserve">This function starts up libvips, see VIPS_INIT().

This function is for bindings which need to start up vips. C programs
should use the VIPS_INIT() macro, which does some extra checks.

See also: VIPS_INIT().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 otherwise</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:space="preserve">name of application</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="insert" c:identifier="vips_insert" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Insert @sub into @main at position @x, @y.

Normally @out shows the whole of @main. If @expand is #TRUE then @out is
made large enough to hold all of @main and @sub.
Any areas of @out not coming from
either @main or @sub are set to @background (default 0).

If @sub overlaps @main,
@sub will appear on top of @main.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_join(), vips_embed(), vips_extract_area().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="main" transfer-ownership="none">
          <doc xml:space="preserve">big image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="sub" transfer-ownership="none">
          <doc xml:space="preserve">small image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">left position of @sub</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">top position of @sub</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="interpolate"
              c:identifier="vips_interpolate"
              introspectable="0">
      <doc xml:space="preserve">Look up the @interpolate method in the class and call it. Use
vips_interpolate_get_method() to get a direct pointer to the function and
avoid the lookup overhead.

You need to set @in and @out up correctly.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interpolate" transfer-ownership="none">
          <doc xml:space="preserve">interpolator to use</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </parameter>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">write result here</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">read source data from here</doc>
          <type name="Region" c:type="VipsRegion*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="invert" c:identifier="vips_invert" introspectable="0">
      <doc xml:space="preserve">For unsigned formats, this operation calculates (max - @in), eg. (255 -
@in) for uchar. For signed and float formats, this operation calculates (-1
@in).

For complex images, only the real part is inverted. See also vips_conj().

See also: vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="join" c:identifier="vips_join" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Join @in1 and @in2 together, left-right or up-down depending on the value
of @direction.

If one is taller or wider than the
other, @out will be has high as the smaller. If @expand is %TRUE, then
the output will be expanded to contain all of the input pixels.

Use @align to set the edge that the images align on. By default, they align
on the edge with the lower value coordinate.

Use @background to set the colour of any pixels in @out which are not
present in either @in1 or @in2.

Use @shim to set the spacing between the images. By default this is 0.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;).

If you are going to be joining many thousands of images in a regular
grid, vips_arrayjoin() is a better choice.

See also: vips_arrayjoin(), vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in1" transfer-ownership="none">
          <doc xml:space="preserve">first input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in2" transfer-ownership="none">
          <doc xml:space="preserve">second input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">join horizontally or vertically</doc>
          <type name="Direction" c:type="VipsDirection"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegload" c:identifier="vips_jpegload" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read a JPEG file into a VIPS image. It can read most 8-bit JPEG images,
including CMYK and YCbCr.

@shrink means shrink by this integer factor during load.  Possible values
are 1, 2, 4 and 8. Shrinking during read is very much faster than
decompressing the whole image and then shrinking later.

Setting @fail to %TRUE makes the JPEG reader fail on any warnings.
This can be useful for detecting truncated files, for example. Normally
reading these produces a warning, but no fatal error.

Setting @autorotate to %TRUE will make the loader interpret the EXIF
Orientation field and automatically rotate the image appropriately during
load. After rotation, the Orientation tag will be removed to prevent
accidental double-rotation.

Using @autorotate can be much slower than doing the rotate later
in processing. See vips_autorot().

Example:

|[
vips_jpegload( "fred.jpg", &amp;amp;out,
	"shrink", 8,
	"fail", TRUE,
	NULL );
]|

Any embedded ICC profiles are ignored: you always just get the RGB from
the file. Instead, the embedded profile will be attached to the image as
@VIPS_META_ICC_NAME ("icc-profile-data"). You need to use something like
vips_icc_import() to get CIE values from the file.

EXIF metadata is attached as @VIPS_META_EXIF_NAME ("exif-data"), IPCT as
@VIPS_META_IPCT_NAME ("ipct-data"), and XMP as VIPS_META_XMP_NAME
("xmp-data").

The int metadata item "jpeg-multiscan" is set to the result of
jpeg_has_multiple_scans(). Interlaced jpeg images need a large amount of
memory to load, so this field gives callers a chance to handle these
images differently.

The EXIF thumbnail, if present, is attached to the image as
"jpeg-thumbnail-data". See vips_image_get_blob().

This function only reads the image header and does not decompress any pixel
data. Decompression only occurs when pixels are accessed.

See also: vips_jpegload_buffer(), vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegload_buffer"
              c:identifier="vips_jpegload_buffer"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read a JPEG-formatted memory block into a VIPS image. Exactly as
vips_jpegload(), but read from a memory buffer.

You must not free the buffer while @out is active. The
#VipsObject::postclose signal on @out is a good place to free.

See also: vips_jpegload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">memory area to load</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegsave" c:identifier="vips_jpegsave" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Write a VIPS image to a file as JPEG.

Use @Q to set the JPEG compression factor. Default 75.

Use @profile to give the filename of a profile to be embedded in the JPEG.
This does not affect the pixels which are written, just the way
they are tagged. You can use the special string "none" to mean
"don't attach a profile".

If no profile is specified and the VIPS header
contains an ICC profile named VIPS_META_ICC_NAME ("icc-profile-data"), the
profile from the VIPS header will be attached.

The image is automatically converted to RGB, Monochrome or CMYK before
saving.

EXIF data is constructed from @VIPS_META_EXIF_NAME ("exif-data"), then
modified with any other related tags on the image before being written to
the file.

IPCT as @VIPS_META_IPCT_NAME ("ipct-data") and XMP as VIPS_META_XMP_NAME
("xmp-data") are coded and attached.

If @optimize_coding is set, the Huffman tables are optimised. This is
sllightly slower and produces slightly smaller files.

If @interlace is set, the jpeg files will be interlaced (progressive jpeg,
in jpg parlance). These files may be better for display over a slow network
conection, but need much more memory to encode and decode.

If @strip is set, no EXIF data, IPCT data, ICC profile or XMP metadata is
written into the output file.

If @no-subsample is set, chrominance subsampling is disabled. This will
improve quality at the cost of larger file size. Useful for high Q factors.

If @trellis_quant is set and the version of libjpeg supports it
(e.g. mozjpeg &gt;= 3.0), apply trellis quantisation to each 8x8 block.
Reduces file size but increases compression time.

If @overshoot_deringing is set and the version of libjpeg supports it
(e.g. mozjpeg &gt;= 3.0), apply overshooting to samples with extreme values
for example 0 and 255 for 8-bit. Overshooting may reduce ringing artifacts
from compression, in particular in areas where black text appears on a
white background.

If @optimize_scans is set and the version of libjpeg supports it
(e.g. mozjpeg &gt;= 3.0), split the spectrum of DCT coefficients into
separate scans. Reduces file size but increases compression time.

See also: vips_jpegsave_buffer(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegsave_buffer"
              c:identifier="vips_jpegsave_buffer"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

As vips_jpegsave(), but save to a memory buffer.

The address of the buffer is returned in @obuf, the length of the buffer in
@olen. You are responsible for freeing the buffer with g_free() when you
are done with it.

See also: vips_jpegsave(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return output buffer here</doc>
          <type name="gpointer" c:type="void**"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">return output length here</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegsave_mime"
              c:identifier="vips_jpegsave_mime"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

As vips_jpegsave(), but save as a mime jpeg on stdout.

See also: vips_jpegsave(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="labelregions"
              c:identifier="vips_labelregions"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Repeatedly scans @in for regions of 4-connected pixels
with the same pixel value. Every time a region is discovered, those
pixels are marked in @mask with a unique serial number. Once all pixels
have been labelled, the operation returns, setting @segments to the number
of discrete regions which were detected.

@mask is always a 1-band #VIPS_FORMAT_INT image of the same dimensions as
@in.

This operation is useful for, for example, blob counting. You can use the
morphological operators to detect and isolate a series of objects, then use
vips_labelregions() to number them all.

Use vips_hist_find_indexed() to (for example) find blob coordinates.

See also: vips_hist_find_indexed().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to test</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">write labelled regions here</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="leak_set" c:identifier="vips_leak_set">
      <doc xml:space="preserve">Turn on or off vips leak checking. See also --vips-leak and
vips_add_option_entries().

You should call this very early in your program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="leak" transfer-ownership="none">
          <doc xml:space="preserve">turn leak checking on or off</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="less" c:identifier="vips_less" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESS on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="less_const"
              c:identifier="vips_less_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESS on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="less_const1"
              c:identifier="vips_less_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESS on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="lesseq" c:identifier="vips_lesseq" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESSEQ on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="lesseq_const"
              c:identifier="vips_lesseq_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESSEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="lesseq_const1"
              c:identifier="vips_lesseq_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESSEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="linear" c:identifier="vips_linear" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Pass an image through a linear transform, ie. (@out = @in * @a + @b). Output
is float for integer input, double for double input, complex for
complex input and double complex for double complex input. Set @uchar to
output uchar pixels.

If the arrays of constants have just one element, that constant is used for
all image bands. If the arrays have more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_linear1(), vips_add().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to transform</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">array of constants for multiplication</doc>
          <array length="4" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">array of constants for addition</doc>
          <array length="4" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">length of constant arrays</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="linear1" c:identifier="vips_linear1" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Run vips_linear() with a single constant.

See also: vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to transform</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">constant for multiplication</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">constant for addition</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="linecache"
              c:identifier="vips_linecache"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation behaves rather like vips_copy() between images
@in and @out, except that it keeps a cache of computed scanlines.

The number of lines cached is enough for a small amount of non-local
access. If you know you will not be making any non-local access, you can
save some memory and set @access to #VIPS_ACCESS_SEQUENTIAL_UNBUFFERED.

Each cache tile is made with a single call to
vips_region_prepare().

When the cache fills, a tile is chosen for reuse. If @access is
#VIPS_ACCESS_RANDOM, then the least-recently-used tile is reused. If
@access is #VIPS_ACCESS_SEQUENTIAL or #VIPS_ACCESS_SEQUENTIAL_UNBUFFERED,
the top-most tile is reused. @access defaults to #VIPS_ACCESS_RANDOM.

@tile_height can be used to set the size of the strips that
vips_linecache() uses. The default is 1 (a single scanline).

Normally, only a single thread at once is allowed to calculate tiles. If
you set @threaded to %TRUE, vips_linecache() will allow many threads to
calculate tiles at once and share the cache between them.

See also: vips_cache(), vips_tilecache().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="log" c:identifier="vips_log" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_LOG on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="log10" c:identifier="vips_log10" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_LOG10 on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="lshift" c:identifier="vips_lshift" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="lshift_const"
              c:identifier="vips_lshift_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="lshift_const1"
              c:identifier="vips_lshift_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="magickload"
              c:identifier="vips_magickload"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read in an image using libMagick, the ImageMagick library. This library can
read more than 80 file formats, including SVG, BMP, EPS, DICOM and many
others.
The reader can handle any ImageMagick image, including the float and double
formats. It will work with any quantum size, including HDR. Any metadata
attached to the libMagick image is copied on to the VIPS image.

The reader should also work with most versions of GraphicsMagick. See the
"--with-magickpackage" configure option.

Normally it will only load the first image in a many-image sequence (such
as a GIF). Set @all_frames to true to read the whole image sequence.

@density is "WxH" in DPI, e.g. "600x300" or "600" (default is "72x72"). See
the [density
docs](http://www.imagemagick.org/script/command-line-options.php#density)
on the imagemagick website.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="magickload_buffer"
              c:identifier="vips_magickload_buffer"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read an image memory block using libMagick into a VIPS image. Exactly as
vips_magickload(), but read from a memory source.

You must not free the buffer while @out is active. The
#VipsObject::postclose signal on @out is a good place to free.

See also: vips_magickload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">memory area to load</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="malloc" c:identifier="vips_malloc">
      <doc xml:space="preserve">g_malloc() local to @object, that is, the memory will be automatically
freed for you when the object is closed. If @object is %NULL, you need to
free the memory explicitly with g_free().

This function cannot fail. See vips_tracked_malloc() if you are
allocating large amounts of memory.

See also: vips_tracked_malloc().</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">allocate memory local to this #VipsObject, or %NULL</doc>
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes to allocate</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="math" c:identifier="vips_math" introspectable="0">
      <doc xml:space="preserve">Perform various functions in -lm, the maths library, on images.

Angles are expressed in degrees. The output type is float unless the
input is double, in which case the output is double.

Non-complex images only.

See also: vips_math2().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math" transfer-ownership="none">
          <doc xml:space="preserve">math operation to perform</doc>
          <type name="OperationMath" c:type="VipsOperationMath"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="math2" c:identifier="vips_math2" introspectable="0">
      <doc xml:space="preserve">This operation calculates a 2-ary maths operation on a pair of images
and writes the result to @out. The images may have any
non-complex format. @out is float except in the case that either of @left
or @right are double, in which case @out is also double.

It detects division by zero, setting those pixels to zero in the output.
Beware: it does this silently!

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;), and that format is the
result type.

See also: vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math2" transfer-ownership="none">
          <doc xml:space="preserve">math operation to perform</doc>
          <type name="OperationMath2" c:type="VipsOperationMath2"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="math2_const"
              c:identifier="vips_math2_const"
              introspectable="0">
      <doc xml:space="preserve">This operation calculates various 2-ary maths operations on an image and
an array of constants and writes the result to @out.
The image may have any
non-complex format. @out is float except in the case that @in
is double, in which case @out is also double.

It detects division by zero, setting those pixels to zero in the output.
Beware: it does this silently!

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_math2(), vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math2" transfer-ownership="none">
          <doc xml:space="preserve">math operation to perform</doc>
          <type name="OperationMath2" c:type="VipsOperationMath2"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="math2_const1"
              c:identifier="vips_math2_const1"
              introspectable="0">
      <doc xml:space="preserve">This operation calculates various 2-ary maths operations on an image and
a constant. See vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math2" transfer-ownership="none">
          <doc xml:space="preserve">math operation to perform</doc>
          <type name="OperationMath2" c:type="VipsOperationMath2"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="matload" c:identifier="vips_matload" introspectable="0">
      <doc xml:space="preserve">Read a Matlab save file into a VIPS image.

This operation searches the save
file for the first array variable with between 1 and 3 dimensions and loads
it as an image. It will not handle complex images. It does not handle
sparse matrices.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="matrixload"
              c:identifier="vips_matrixload"
              introspectable="0">
      <doc xml:space="preserve">Reads a matrix from a file.

Matrix files have a simple format that's supposed to be easy to create with
a text editor or a spreadsheet.

The first line has four numbers for width, height, scale and
offset (scale and offset may be omitted, in which case they default to 1.0
and 0.0). Scale must be non-zero. Width and height must be positive
integers. The numbers are separated by any mixture of spaces, commas,
tabs and quotation marks ("). The scale and offset fields may be
floating-point, and must use '.'
as a decimal separator.

Subsequent lines each hold one line of matrix data, with numbers again
separated by any mixture of spaces, commas,
tabs and quotation marks ("). The numbers may be floating-point, and must
use '.'
as a decimal separator.

Extra characters at the ends of lines or at the end of the file are
ignored.

See also: vips_csvload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="matrixprint"
              c:identifier="vips_matrixprint"
              introspectable="0">
      <doc xml:space="preserve">Print @in to %stdout in matrix format. See vips_matrixload() for a
description of the format.

See also: vips_matrixload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to print</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="matrixsave"
              c:identifier="vips_matrixsave"
              introspectable="0">
      <doc xml:space="preserve">Write @in to @filename in matrix format. See vips_matrixload() for a
description of the format.

See also: vips_matrixload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="max" c:identifier="vips_max" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation finds the maximum value in an image.

By default it finds the single largest value. If @size is set &gt;1, it will
find the @size largest values. It will stop searching early if has found
enough values.

It operates on all
bands of the input image: use vips_stats() if you need to find an
maximum for each band.

For complex images, this operation finds the maximum modulus.

You can read out the position of the maximum with @x and @y. You can read
out arrays of the values and positions of the top @size maxima with
@out_array, @x_array and @y_array. These values are returned sorted from
largest to smallest.

See also: vips_min(), vips_stats().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output pixel maximum</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="measure" c:identifier="vips_measure" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Analyse a grid of colour patches, producing an array of patch averages.
The mask has a row for each measured patch and a column for each image
band. The operations issues a warning if any patch has a deviation more
than 20% of
the mean. Only the central 50% of each patch is averaged.

If the chart does not fill the whole image, use the optional @left, @top,
@width, @height arguments to indicate the
position of the chart.

See also: vips_avg(), vips_deviate().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to measure</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">array of measurements</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <doc xml:space="preserve">patches across chart</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="v" transfer-ownership="none">
          <doc xml:space="preserve">patches down chart</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="median" c:identifier="vips_median" introspectable="0">
      <doc xml:space="preserve">A convenience function equivalent to:

 vips_rank( in, out, size, size, (size * size) / 2 );

See also: vips_rank().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">size of region</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="min" c:identifier="vips_min" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation finds the minimum value in an image.

By default it finds the single smallest value. If @size is set &gt;1, it will
find the @size smallest values. It will stop searching early if has found
enough values.

It operates on all
bands of the input image: use vips_stats() if you need to find an
minimum for each band.

For complex images, this operation finds the minimum modulus.

You can read out the position of the minimum with @x and @y. You can read
out arrays of the values and positions of the top @size minima with
@out_array, @x_array and @y_array.
These values are returned sorted from
smallest to largest.

See also: vips_min(), vips_stats().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output pixel minimum</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="more" c:identifier="vips_more" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_MORE on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="more_const"
              c:identifier="vips_more_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_MORE on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="more_const1"
              c:identifier="vips_more_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_MORE on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="moreeq" c:identifier="vips_moreeq" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_MOREEQ on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="moreeq_const"
              c:identifier="vips_moreeq_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_MOREEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="moreeq_const1"
              c:identifier="vips_moreeq_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_MOREEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="morph" c:identifier="vips_morph" introspectable="0">
      <doc xml:space="preserve">Performs a morphological operation on @in using @mask as a
structuring element.

The image should have 0 (black) for no object and 255
(non-zero) for an object. Note that this is the reverse of the usual
convention for these operations, but more convenient when combined with the
boolean operators. The output image is the same
size as the input image: edge pxels are made by expanding the input image
as necessary.

Mask coefficients can be either 0 (for object) or 255 (for background)
or 128 (for do not care).  The origin of the mask is at location
(m.xsize / 2, m.ysize / 2), integer division.  All algorithms have been
based on the book "Fundamentals of Digital Image Processing" by A. Jain,
pp 384-388, Prentice-Hall, 1989.

For #VIPS_OPERATION_MORPHOLOGY_ERODE,
the whole mask must match for the output pixel to be
set, that is, the result is the logical AND of the selected input pixels.

For #VIPS_OPERATION_MORPHOLOGY_DILATE,
the output pixel is set if any part of the mask
matches, that is, the result is the logical OR of the selected input pixels.

See the boolean operations vips_andimage(), vips_orimage() and
vips_eorimage()
for analogues of the usual set difference and set union operations.

Operations are performed using the processor's vector unit,
if possible. Disable this with --vips-novector or IM_NOVECTOR.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">morphology with this mask</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="morph" transfer-ownership="none">
          <doc xml:space="preserve">operation to perform</doc>
          <type name="OperationMorphology" c:type="VipsOperationMorphology"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="msb" c:identifier="vips_msb" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Turn any integer image to 8-bit unsigned char by discarding all but the most
significant byte. Signed values are converted to unsigned by adding 128.

Use @band to make a one-band 8-bit image.

This operator also works for LABQ coding.

See also: vips_scale(), vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="multiply" c:identifier="vips_multiply" introspectable="0">
      <doc xml:space="preserve">This operation calculates @left * @right and writes the result to @out.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;), then the
following table is used to determine the output type:

&lt;table&gt;
  &lt;title&gt;VipsMultiply type promotion&lt;/title&gt;
  &lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
    &lt;thead&gt;
      &lt;row&gt;
        &lt;entry&gt;input type&lt;/entry&gt;
        &lt;entry&gt;output type&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;uchar&lt;/entry&gt;
        &lt;entry&gt;ushort&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;char&lt;/entry&gt;
        &lt;entry&gt;short&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;ushort&lt;/entry&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;short&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;int&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;float&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double&lt;/entry&gt;
        &lt;entry&gt;double&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_add(), vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="nickname_find" c:identifier="vips_nickname_find">
      <doc xml:space="preserve">Return the VIPS nickname for a %GType. Handy for language bindings.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the class nickname.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">#GType to search for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="notequal" c:identifier="vips_notequal" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_NOTEQ on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="notequal_const"
              c:identifier="vips_notequal_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_NOTEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="notequal_const1"
              c:identifier="vips_notequal_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_RELATIONAL_NOTEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="openexrload"
              c:identifier="vips_openexrload"
              introspectable="0">
      <doc xml:space="preserve">Read a OpenEXR file into a VIPS image.

The reader can handle scanline and tiled OpenEXR images. It can't handle
OpenEXR colour management, image attributes, many pixel formats, anything
other than RGBA.

This reader uses the rather limited OpenEXR C API. It should really be
redone in C++.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="openslideload"
              c:identifier="vips_openslideload"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read a virtual slide supported by the OpenSlide library into a VIPS image.
OpenSlide supports images in Aperio, Hamamatsu, MIRAX, Sakura, Trestle,
and Ventana formats.

To facilitate zooming, virtual slide formats include multiple scaled-down
versions of the high-resolution image.  These are typically called
"levels".  By default, vips_openslideload() reads the highest-resolution
level (level 0).  Set @level to the level number you want.

In addition to the slide image itself, virtual slide formats sometimes
include additional images, such as a scan of the slide's barcode.
OpenSlide calls these "associated images".  To read an associated image,
set @associated to the image's name.
A slide's associated images are listed in the
"slide-associated-images" metadata item.

The output of this operator is always RGBA.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="orimage" c:identifier="vips_orimage" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_OR on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="orimage_const"
              c:identifier="vips_orimage_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_OR on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="orimage_const1"
              c:identifier="vips_orimage_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_OR on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="path_filename7" c:identifier="vips_path_filename7">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_mode7" c:identifier="vips_path_mode7">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pngload" c:identifier="vips_pngload" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read a PNG file into a VIPS image. It can read all png images, including 8-
and 16-bit images, 1 and 3 channel, with and without an alpha channel.

Any ICC profile is read and attached to the VIPS image.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pngload_buffer"
              c:identifier="vips_pngload_buffer"
              introspectable="0">
      <doc xml:space="preserve">Read a PNG-formatted memory block into a VIPS image. It can read all png
images, including 8- and 16-bit images, 1 and 3 channel, with and without
an alpha channel.

Any ICC profile is read and attached to the VIPS image.

You must not free the buffer while @out is active. The
#VipsObject::postclose signal on @out is a good place to free.

See also: vips_pngload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">memory area to load</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pngsave" c:identifier="vips_pngsave" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Write a VIPS image to a file as PNG.

@compression means compress with this much effort (0 - 9). Default 6.

Set @interlace to %TRUE to interlace the image with ADAM7
interlacing. Beware
than an interlaced PNG can be up to 7 times slower to write than a
non-interlaced image.

Use @profile to give the filename of a profile to be embedded in the PNG.
This does not affect the pixels which are written, just the way
they are tagged. You can use the special string "none" to mean
"don't attach a profile".

If @profile is specified and the VIPS header
contains an ICC profile named VIPS_META_ICC_NAME ("icc-profile-data"), the
profile from the VIPS header will be attached.

Use @filter to specify one or more filters (instead of adaptive filtering),
see #VipsForeignPngFilter.

The image is automatically converted to RGB, RGBA, Monochrome or Mono +
alpha before saving. Images with more than one byte per band element are
saved as 16-bit PNG, others are saved as 8-bit PNG.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pngsave_buffer"
              c:identifier="vips_pngsave_buffer"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

As vips_pngsave(), but save to a memory buffer.

The address of the buffer is returned in @obuf, the length of the buffer in
@olen. You are responsible for freeing the buffer with g_free() when you
are done with it.

See also: vips_pngsave(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return output buffer here</doc>
          <type name="gpointer" c:type="void**"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">return output length here</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="polar" c:identifier="vips_polar" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_COMPLEX_POLAR on an image. See vips_complex().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pow" c:identifier="vips_pow" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH2_POW on a pair of images. See
vips_math2().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pow_const"
              c:identifier="vips_pow_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH2_POW on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pow_const1"
              c:identifier="vips_pow_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH2_POW on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ppmload" c:identifier="vips_ppmload" introspectable="0">
      <doc xml:space="preserve">Read a PPM/PBM/PGM/PFM file into a VIPS image.

It can read 1, 8, 16 and 32 bit images, colour or monochrome,
stored in binary or in ASCII. One bit images become 8 bit VIPS images,
with 0 and 255 for 0 and 1.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ppmsave" c:identifier="vips_ppmsave" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Write a VIPS image to a file as PPM. It can write 1, 8, 16 or
32 bit unsigned integer images, float images, colour or monochrome,
stored as binary or ASCII.
Integer images of more than 8 bits can only be stored in ASCII.

When writing float (PFM) images the scale factor is set from the
"pfm-scale" metadata.

Set @ascii to %TRUE to write as human-readable ASCII. Normally data is
written in binary.

Set @squash to %TRUE to squash 8-bit images down to one bit. The saver does
no dithering, that's up to you.

See also: vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="premultiply"
              c:identifier="vips_premultiply"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Premultiplies any alpha channel.
The final band is taken to be the alpha
and the bands are transformed as:

|[
  alpha = clip( 0, in[in.bands - 1], @max_alpha );
  norm = alpha / @max_alpha;
  out = [in[0] * norm, ..., in[in.bands - 1] * norm, alpha];
|]

So for an N-band image, the first N - 1 bands are multiplied by the clipped
and normalised final band, the final band is clipped.
If there is only a single band,
the image is passed through unaltered.

The result is
#VIPS_FORMAT_FLOAT unless the input format is #VIPS_FORMAT_DOUBLE, in which
case the output is double as well.

@max_alpha has the default value 255. You will need to set this to 65535
for images with a 16-bit alpha, or perhaps 1.0 for images with a float
alpha.

Non-complex images only.

See also: vips_unpremultiply(), vips_flatten().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="profile" c:identifier="vips_profile" introspectable="0">
      <doc xml:space="preserve">vips_profile() searches inward from the edge of @in and finds the
first non-zero pixel. Pixels in @columns have the distance from the top edge
to the first non-zero pixel in that column, @rows has the distance from the
left edge to the first non-zero pixel in that row.

See also: vips_project(), vips_hist_find().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="columns" transfer-ownership="none">
          <doc xml:space="preserve">distances from top edge</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="rows" transfer-ownership="none">
          <doc xml:space="preserve">distances from left edge</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="progress_set"
              c:identifier="vips_progress_set"
              moved-to="Progress.set">
      <doc xml:space="preserve">If set, vips will print messages about the progress of computation to
stdout. This can also be enabled with the --vips-progress option, or by
setting the environment variable VIPS_PROGRESS.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="progress" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to enable progress messages</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="project" c:identifier="vips_project" introspectable="0">
      <doc xml:space="preserve">Find the horizontal and vertical projections of an image, ie. the sum
of every row of pixels, and the sum of every column of pixels. The output
format is uint, int or double, depending on the input format.

Non-complex images only.

See also: vips_hist_find(), vips_profile().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="columns" transfer-ownership="none">
          <doc xml:space="preserve">sums of columns</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="rows" transfer-ownership="none">
          <doc xml:space="preserve">sums of rows</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pythagoras" c:identifier="vips_pythagoras">
      <doc xml:space="preserve">Pythagorean distance between two points in colour space. Lab/XYZ/CMC etc.</doc>
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="L1" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a1" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b1" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="L2" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a2" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b2" transfer-ownership="none">
          <doc xml:space="preserve">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rad2float"
              c:identifier="vips_rad2float"
              introspectable="0">
      <doc xml:space="preserve">Unpack a RAD (#VIPS_CODING_RAD) image to a three-band float image.

See also: vips_float2rad(), vips_LabQ2LabS().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="radload" c:identifier="vips_radload" introspectable="0">
      <doc xml:space="preserve">Read a Radiance (HDR) file into a VIPS image.

Radiance files are read as #VIPS_CODING_RAD. They have one byte for each of
red, green and blue, and one byte of shared exponent. Some operations (like
vips_extract_area()) can work directly with images in this format, but
mmany (all the arithmetic operations, for example) will not. Unpack
#VIPS_CODING_RAD images to 3 band float with vips_rad2float() if
you want to do arithmetic on them.

This operation ignores some header fields, like VIEW and DATE. It will not
rotate/flip as the FORMAT string asks.

Sections of this reader from Greg Ward and Radiance with kind permission.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="radsave" c:identifier="vips_radsave" introspectable="0">
      <doc xml:space="preserve">Write a VIPS image in Radiance (HDR) format.

Sections of this reader from Greg Ward and Radiance with kind permission.

See also: vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rank" c:identifier="vips_rank" introspectable="0">
      <doc xml:space="preserve">vips_rank() does rank filtering on an image. A window of size @width by
@height is passed over the image. At each position, the pixels inside the
window are sorted into ascending order and the pixel at position @index is
output. @index numbers from 0.

It works for any non-complex image type, with any number of bands.
The input is expanded by copying edge pixels before performing the
operation so that the output image has the same size as the input.
Edge pixels in the output image are therefore only approximate.

For a median filter with mask size m (3 for 3x3, 5 for 5x5, etc.) use

 vips_rank( in, out, m, m, m * m / 2 );

The special cases n == 0 and n == m * m - 1 are useful dilate and
expand operators.

See also: vips_conv(), vips_median(), vips_spcor().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">width of region</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">height of region</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="index" transfer-ownership="none">
          <doc xml:space="preserve">select pixel</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rawload" c:identifier="vips_rawload" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation mmaps the file, setting @out so that access to that
image will read from the file.

@out will be a 8-bit uchar image with @bands image bands, so @bands can
be thought of as meaning "number of bytes per pixel". Use functions
like vips_copy() to set the exact band format, number of bands, byte
ordering and so on.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">width of image in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">height of image in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:space="preserve">number of image bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rawsave" c:identifier="vips_rawsave" introspectable="0">
      <doc xml:space="preserve">Writes the pixels in @in to the file @filename with no header or other
metadata.

See also: vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rawsave_fd"
              c:identifier="vips_rawsave_fd"
              introspectable="0">
      <doc xml:space="preserve">Writes the pixels in @in to the @fd with no header or other
metadata.  Handy for implementing other savers.

See also: vips_rawsave().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="real" c:identifier="vips_real" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_COMPLEXGET_REAL on an image. See vips_complexget().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="recomb" c:identifier="vips_recomb" introspectable="0">
      <doc xml:space="preserve">This operation recombines an image's bands. Each pixel in @in is treated as
an n-element vector, where n is the number of bands in @in, and multipled by
the n x m matrix @m to produce the m-band image @out.

@out is always float, unless @in is double, in which case @out is double
too. No complex images allowed.

It's useful for various sorts of colour space conversions.

See also: vips_bandmean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="m" transfer-ownership="none">
          <doc xml:space="preserve">recombination matrix</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rect" c:identifier="vips_rect" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_COMPLEX_RECT on an image. See vips_complex().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="relational"
              c:identifier="vips_relational"
              introspectable="0">
      <doc xml:space="preserve">Perform various relational operations on pairs of images.

The output type is always uchar, with 0 for FALSE and 255 for TRUE.

Less-than and greater-than for complex images compare the modulus.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;).

To decide if pixels match exactly, that is have the same value in every
band, use vips_bandbool() after this operation to AND or OR image bands
together.

See also: vips_boolean(), vips_bandbool(), vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="relational" transfer-ownership="none">
          <doc xml:space="preserve">relational operation to perform</doc>
          <type name="OperationRelational" c:type="VipsOperationRelational"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="relational_const"
              c:identifier="vips_relational_const"
              introspectable="0">
      <doc xml:space="preserve">Perform various relational operations on an image and an array of
constants.

The output type is always uchar, with 0 for FALSE and 255 for TRUE.

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_boolean(), vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="relational" transfer-ownership="none">
          <doc xml:space="preserve">relational operation to perform</doc>
          <type name="OperationRelational" c:type="VipsOperationRelational"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="relational_const1"
              c:identifier="vips_relational_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform various relational operations on an image and a constant. See
vips_relational_const().

See also: vips_boolean(), vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="relational" transfer-ownership="none">
          <doc xml:space="preserve">relational operation to perform</doc>
          <type name="OperationRelational" c:type="VipsOperationRelational"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="remainder"
              c:identifier="vips_remainder"
              introspectable="0">
      <doc xml:space="preserve">This operation calculates @left % @right (remainder after integer division)
and writes the result to @out. The images may have any
non-complex format. For float formats, vips_remainder() calculates @in1 -
@in2 * floor (@in1 / @in2).

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;), and that format is the
result type.

See also: vips_remainder_const(), vips_divide(), vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="remainder_const"
              c:identifier="vips_remainder_const"
              introspectable="0">
      <doc xml:space="preserve">This operation calculates @in % @c (remainder after division by an
array of constants)
and writes the result to @out.
The image may have any
non-complex format. For float formats, vips_remainder_const() calculates
@in - @c * floor (@in / @c).

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_remainder(), vips_divide(), vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="remainder_const1"
              c:identifier="vips_remainder_const1"
              introspectable="0">
      <doc xml:space="preserve">This operation calculates @in % @c (remainder after division by a
constant)
and writes the result to @out.
The image may have any
non-complex format. For float formats, vips_remainder_const() calculates
@in - @c * floor (@in / @c).

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_remainder(), vips_divide(), vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="replicate"
              c:identifier="vips_replicate"
              introspectable="0">
      <doc xml:space="preserve">Repeats an image many times.

See also: vips_extract_area().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="across" transfer-ownership="none">
          <doc xml:space="preserve">repeat input this many times across</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="down" transfer-ownership="none">
          <doc xml:space="preserve">repeat input this many times down</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rint" c:identifier="vips_rint" introspectable="0">
      <doc xml:space="preserve">Round to an integral value with #VIPS_OPERATION_ROUND_RINT. See
vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rot" c:identifier="vips_rot" introspectable="0">
      <doc xml:space="preserve">Rotate @in by a multiple of 90 degrees.

See also: vips_flip().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve">rotation angle</doc>
          <type name="Angle" c:type="VipsAngle"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rot45" c:identifier="vips_rot45" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Rotate @in by a multiple of 45 degrees. Odd-length sides and square images
only.

See also: vips_rot().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="round" c:identifier="vips_round" introspectable="0">
      <doc xml:space="preserve">Round to an integral value.

Copy for integer types, round float and
complex types.

The format of @out is always the same as @in, so you may wish to cast to an
integer format afterwards.

See also: vips_cast()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="round" transfer-ownership="none">
          <doc xml:space="preserve">#VipsOperationRound rounding operation to perform</doc>
          <type name="OperationRound" c:type="VipsOperationRound"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rshift" c:identifier="vips_rshift" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_RSHIFT on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rshift_const"
              c:identifier="vips_rshift_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rshift_const1"
              c:identifier="vips_rshift_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_BOOLEAN_RSHIFT on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sRGB2HSV" c:identifier="vips_sRGB2HSV" introspectable="0">
      <doc xml:space="preserve">Convert to HSV.

HSV is a crude polar coordinate system for RGB images. It is provided for
compatibility with other image processing systems. See vips_Lab2LCh() for a
much better colour space.

See also: vips_HSV2sRGB(), vips_Lab2LCh().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sRGB2scRGB"
              c:identifier="vips_sRGB2scRGB"
              introspectable="0">
      <doc xml:space="preserve">Convert an sRGB image to scRGB. The input image can be 8 or 16-bit
unsigned int.

If the input image is unsigned 16-bit, any extra channels after RGB are
divided by 256. Thus, scRGB alpha is always 0 - 255.99.

See also: vips_scRGB2XYZ(), vips_scRGB2sRGB(), vips_rad2float().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="scRGB2BW" c:identifier="vips_scRGB2BW" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Convert an scRGB image to greyscale. Set @depth to 16 to get 16-bit output.

If @depth is 16, any extra channels after RGB are
multiplied by 256.

See also: vips_LabS2LabQ(), vips_sRGB2scRGB(), vips_rad2float().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="scRGB2XYZ"
              c:identifier="vips_scRGB2XYZ"
              introspectable="0">
      <doc xml:space="preserve">Turn XYZ to scRGB.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="scRGB2sRGB"
              c:identifier="vips_scRGB2sRGB"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Convert an scRGB image to sRGB. Set @depth to 16 to get 16-bit output.

If @depth is 16, any extra channels after RGB are
multiplied by 256.

See also: vips_LabS2LabQ(), vips_sRGB2scRGB(), vips_rad2float().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="scale" c:identifier="vips_scale" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Search the image for the maximum and minimum value, then return the image
as unsigned 8-bit, scaled so that the maximum value is 255 and the
minimum is zero.

If @log is set, transform with log10(1.0 + pow(x, @exp)) + .5,
then scale so max == 255. By default, @exp is 0.25.

See also: vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sequential"
              c:identifier="vips_sequential"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation behaves rather like vips_copy() between images
@in and @out, except that it checks that pixels are only requested
top-to-bottom. If a thread makes an out of order request, it is stalled
until the pack catches up.

This operation is useful for loading file formats which are
strictly top-to-bottom, like PNG.

If @trace is true, the operation will print diagnostic messages for each
block of pixels which are processed. This can help find the cause of
non-sequential accesses.

@strip_height can be used to set the size of the tiles that
vips_sequential() uses. The default value is 1.

@access can be set to #VIPS_ACCESS_SEQUENTIAL_UNBUFFERED, meaning don't
keep a large cache behind the read point. This can save some memory.

See also: vips_cache(), vips_linecache(), vips_tilecache().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sharpen" c:identifier="vips_sharpen" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Selectively sharpen the L channel of a LAB image. The input image is
transformed to #VIPS_INTERPRETATION_LABS.

The operation performs a gaussian blur of radius @radius and subtracts
from @in to generate a high-frequency signal. This signal is passed
through a lookup table formed from the five parameters and added back to
@in.

The lookup table is formed like this:

|[
                     ^
                  y2 |- - - - - -----------
                     |         /
                     |        / slope m2
                     |    .../
             -x1     | ...   |
 -------------------...----------------------&gt;
             |   ... |      x1
             |... slope m1
             /       |
            / m2     |
           /         |
          /          |
         /           |
        /            |
 ______/ _ _ _ _ _ _ | -y3
                     |
]|

For printing, we recommend the following settings (the defaults):

|[
  radius == 3
  x1 == 1.5
  y2 == 20         (don't brighten by more than 20 L*)
  y3 == 50         (can darken by up to 50 L*)

  m1 == 1          (some sharpening in flat areas)
  m2 == 2          (more sharpening in jaggy areas)
]|

If you want more or less sharpening, we suggest you just change the m1
and m2 parameters.

The @radius parameter changes the width of the fringe and can be
adjusted according to the output printing resolution. As an approximate
guideline, use 1 for 4 pixels/mm (CRT display resolution), 2 for 8
pixels/mm, 3 for 12 pixels/mm and 4 for 16 pixels/mm (300 dpi == 12
pixels/mm). These figures refer to the image raster, not the half-tone
resolution.

See also: vips_conv().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="shutdown" c:identifier="vips_shutdown">
      <doc xml:space="preserve">Call this to drop caches and close plugins. Run with "--vips-leak" to do
a leak check too. May be called many times.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="sign" c:identifier="vips_sign" introspectable="0">
      <doc xml:space="preserve">Finds the unit vector in the direction of the pixel value. For non-complex
images, it returns a signed char image with values -1, 0, and 1 for negative,
zero and positive pixels. For complex images, it returns a
complex normalised to length 1.

See also: vips_abs().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sin" c:identifier="vips_sin" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_SIN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="spcor" c:identifier="vips_spcor" introspectable="0">
      <doc xml:space="preserve">Calculate a correlation surface.

@ref is placed at every position in @in and the correlation coefficient
calculated. The output
image is always float.

The output
image is the same size as the input. Extra input edge pixels are made by
copying the existing edges outwards.

The correlation coefficient is calculated as:

|[
         sumij (ref(i,j)-mean(ref))(inkl(i,j)-mean(inkl))
c(k,l) = ------------------------------------------------
         sqrt(sumij (ref(i,j)-mean(ref))^2) *
                     sqrt(sumij (inkl(i,j)-mean(inkl))^2)
]|

where inkl is the area of @in centred at position (k,l).

from Niblack "An Introduction to Digital Image Processing",
Prentice/Hall, pp 138.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The output image is always float, unless either of the two inputs is
double, in which case the output is also double.

See also: vips_fastcor().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="ref" transfer-ownership="none">
          <doc xml:space="preserve">reference image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="stats" c:identifier="vips_stats" introspectable="0">
      <doc xml:space="preserve">Find many image statistics in a single pass through the data. @out is a
one-band #VIPS_FORMAT_DOUBLE image of at least 10 columns by n + 1
(where n is number of bands in image @in)
rows. Columns are statistics, and are, in order: minimum, maximum, sum,
sum of squares, mean, standard deviation, x coordinate of minimum, y
coordinate of minimum, x coordinate of maximum, y coordinate of maximum.
Later versions of vips_stats() may add more columns.

Row 0 has statistics for all
bands together, row 1 has stats for band 1, and so on.

See also: vips_avg(), vips_min().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to scan</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">image of statistics</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="strdup" c:identifier="vips_strdup">
      <doc xml:space="preserve">g_strdup() a string. When @object is freed, the string will be freed for
you.  If @object is %NULL, you need to
free the memory explicitly with g_free().

This function cannot fail.

See also: vips_malloc().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">allocate memory local to this #VipsObject, or %NULL</doc>
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">string to copy</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="subsample"
              c:identifier="vips_subsample"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Subsample an image by an integer fraction. This is fast, nearest-neighbour
shrink.

For small horizontal shrinks, this operation will fetch lines of pixels
from @in and then subsample that line. For large shrinks it will fetch
single pixels.

If @point is set, @in will always be sampled in points. This can be faster
if the previous operations in the pipeline are very slow.

See also: vips_affine(), vips_shrink(), vips_zoom().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="xfac" transfer-ownership="none">
          <doc xml:space="preserve">horizontal shrink factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="yfac" transfer-ownership="none">
          <doc xml:space="preserve">vertical shrink factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="subtract" c:identifier="vips_subtract" introspectable="0">
      <doc xml:space="preserve">This operation calculates @in1 - @in2 and writes the result to @out.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;), then the
following table is used to determine the output type:

&lt;table&gt;
  &lt;title&gt;VipsSubtract type promotion&lt;/title&gt;
  &lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
    &lt;thead&gt;
      &lt;row&gt;
        &lt;entry&gt;input type&lt;/entry&gt;
        &lt;entry&gt;output type&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;uchar&lt;/entry&gt;
        &lt;entry&gt;short&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;char&lt;/entry&gt;
        &lt;entry&gt;short&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;ushort&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;short&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;int&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;float&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double&lt;/entry&gt;
        &lt;entry&gt;double&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_add(), vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in1" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in2" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sum" c:identifier="vips_sum" introspectable="0">
      <doc xml:space="preserve">This operation sums all images in @in and writes the result to @out.

If the images differ in size, the smaller images are enlarged to match the
largest by adding zero pixels along the bottom and right.

If the number of bands differs, all but one of the images
must have one band. In this case, n-band images are formed from the
one-band images by joining n copies of the one-band images together, and then
the n-band images are operated upon.

The input images are cast up to the smallest common format (see table
Smallest common format in
&lt;link linkend="libvips-arithmetic"&gt;arithmetic&lt;/link&gt;), then the
following table is used to determine the output type:

&lt;table&gt;
  &lt;title&gt;VipsSum type promotion&lt;/title&gt;
  &lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
    &lt;thead&gt;
      &lt;row&gt;
        &lt;entry&gt;input type&lt;/entry&gt;
        &lt;entry&gt;output type&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;uchar&lt;/entry&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;char&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;ushort&lt;/entry&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;short&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
        &lt;entry&gt;uint&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;int&lt;/entry&gt;
        &lt;entry&gt;int&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;float&lt;/entry&gt;
        &lt;entry&gt;float&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double&lt;/entry&gt;
        &lt;entry&gt;double&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
        &lt;entry&gt;complex&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
        &lt;entry&gt;double complex&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_add().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">array of input images</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="system" c:identifier="vips_system" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

vips_system() runs a command, optionally passing a set of images in and
optionally getting an image back. The command's stdout is returned in @log.

First, if @in is set, the array of images are written to files. See
vips_image_new_temp_file() to see how temporary files are created.
If @in_format is
something like &amp;percnt;s.png, the file will be written in PNG format. By
default, @in_format is &amp;percnt;s.tif.

If @out_format is set, an output filename is formed in the same way.

The command string to run is made by substituting the first set of &amp;percnt;s
in @cmd_format for the names of the input files, if @in is set, and then
the next &amp;percnt;s for the output filename, if @out_format is set.
You can put a number between the &amp;percnt; and the s to change the order
in which the substitution occurs.

The command is executed with popen() and the output captured in @log.

After the command finishes, if @out_format is set, the output image is
opened and returned in @out.
Closing @out image will automatically delete the output file.

Finally the input images are deleted.

For example, this call will run the ImageMagick convert program on an
image, using JPEG files to pass images into and out of the convert command.

|[
VipsArrayImage *in;
VipsImage *out;
char *log;

if (vips_system ("convert %s -swirl 45 %s",
	"in", in,
	"out", &amp;amp;out,
  	"in_format", "%s.jpg",
  	"out_format", "%s.jpg",
  	"log", &amp;amp;log,
  	NULL))
  	error ...
]|</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on failure.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="cmd_format" transfer-ownership="none">
          <doc xml:space="preserve">command to run</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tan" c:identifier="vips_tan" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH_TAN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_shutdown" c:identifier="vips_thread_shutdown">
      <doc xml:space="preserve">Free any thread-private data and flush any profiling information.

This function needs to be called when a thread that has been using vips
exits. It is called for you by vips_shutdown() and for any threads created
by vips_g_thread_new().

You will need to call it from threads created in
other ways or there will be memory leaks. If you do not call it, vips
will generate a warning message.

It may be called many times, and you can continue using vips after
calling it. Calling it too often will reduce performance.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="tiffload" c:identifier="vips_tiffload" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read a TIFF file into a VIPS image. It is a full baseline TIFF 6 reader,
with extensions for tiled images, multipage images, LAB colour space,
pyramidal images and JPEG compression. including CMYK and YCbCr.

@page means load this page from the file. By default the first page (page
0) is read.

Any ICC profile is read and attached to the VIPS image. Any XMP metadata is
read and attached to the image.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tiffload_buffer"
              c:identifier="vips_tiffload_buffer"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Read a TIFF-formatted memory block into a VIPS image. Exactly as
vips_tiffload(), but read from a memory source.

You must not free the buffer while @out is active. The
#VipsObject::postclose signal on @out is a good place to free.

See also: vips_tiffload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">memory area to load</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tiffsave" c:identifier="vips_tiffsave" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Write a VIPS image to a file as TIFF.

Use @compression to set the tiff compression. Currently jpeg, packbits,
fax4, lzw, none and deflate are supported. The default is no compression.
JPEG compression is a good lossy compressor for photographs, packbits is
good for 1-bit images, and deflate is the best lossless compression TIFF
can do. LZW has patent problems and is no longer recommended.

Use @Q to set the JPEG compression factor. Default 75.

Use @predictor to set the predictor for lzw and deflate compression.

Predictor is not set by default. There are three predictor values recognised
at the moment (2007, July): 1 is no prediction, 2 is a horizontal
differencing and 3 is a floating point predictor. Refer to the libtiff
specifications for further discussion of various predictors. In short,
predictor helps to better compress image, especially in case of digital
photos or scanned images and bit depths &gt; 8. Try it to find whether it
works for your images.

Use @profile to give the filename of a profile to be embedded in the TIFF.
This does not affect the pixels which are written, just the way
they are tagged. You can use the special string "none" to mean
"don't attach a profile".

If no profile is specified and the VIPS header
contains an ICC profile named VIPS_META_ICC_NAME ("icc-profile-data"), the
profile from the VIPS header will be attached.

Set @tile to TRUE to write a tiled tiff.  By default tiff are written in
strips. Use @tile_width and @tile_height to set the tile size. The defaiult
is 128 by 128.

Set @pyramid to write the image as a set of images, one per page, of
decreasing size.

Set @squash to make 8-bit uchar images write as 1-bit TIFFs. Values &gt;128
are written as white, values &lt;=128 as black. Normally vips will write
MINISBLACK TIFFs where black is a 0 bit, but if you set @miniswhite, it
will use 0 for a white bit. Many pre-press applications only work with
images which use this sense. @miniswhite only affects one-bit images, it
does nothing for greyscale images.

Use @resunit to override the default resolution unit.
The default
resolution unit is taken from the header field "resolution-unit"
(#VIPS_META_RESOLUTION_UNIT in C). If this field is not set, then
VIPS defaults to cm.

Use @xres and @yres to override the default horizontal and vertical
resolutions. By default these values are taken from the VIPS image header.
libvips resolution is always in pixels per millimetre.

Set @bigtiff to attempt to write a bigtiff.
Bigtiff is a variant of the TIFF
format that allows more than 4GB in a file.

If @in has a field called VIPS_META_XMP_NAME ("xmp-data") it is written to
the tiff image.

See also: vips_tiffload(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tilecache"
              c:identifier="vips_tilecache"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

This operation behaves rather like vips_copy() between images
@in and @out, except that it keeps a cache of computed pixels.
This cache is made of up to @max_tiles tiles (a value of -1
means any number of tiles), and each tile is of size @tile_width
by @tile_height pixels.

Each cache tile is made with a single call to
vips_region_prepare().

When the cache fills, a tile is chosen for reuse. If @access is
#VIPS_ACCESS_RANDOM, then the least-recently-used tile is reused. If
@access is #VIPS_ACCESS_SEQUENTIAL or #VIPS_ACCESS_SEQUENTIAL_UNBUFFERED,
the top-most tile is reused.

By default, @tile_width and @tile_height are 128 pixels, and the operation
will cache up to 1,000 tiles. @access defaults to #VIPS_ACCESS_RANDOM.

Normally, only a single thread at once is allowed to calculate tiles. If
you set @threaded to %TRUE, vips_tilecache() will allow many threads to
calculate tiles at once, and share the cache between them.

Normally the cache is dropped when computation finishes. Set @persistent to
%TRUE to keep the cache between computations.

See also: vips_cache(), vips_linecache().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_close" c:identifier="vips_tracked_close">
      <doc xml:space="preserve">Exactly as close(2), but update the number of files currently open via
vips_tracked_get_files(). This is used
by the vips operation cache to drop cache when the number of files
available is low.

You must only close file descriptors opened with vips_tracked_open().

See also: vips_tracked_open(), vips_tracked_get_files().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a file descriptor, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">file to close()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_free" c:identifier="vips_tracked_free">
      <doc xml:space="preserve">Only use it to free
memory that was previously allocated with vips_tracked_malloc() with a
%NULL first argument.

See also: vips_tracked_malloc().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="s"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">memory to free</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_get_allocs" c:identifier="vips_tracked_get_allocs">
      <doc xml:space="preserve">Returns the number of active allocations.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of active allocations</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="tracked_get_files" c:identifier="vips_tracked_get_files">
      <doc xml:space="preserve">Returns the number of open files.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of open files</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="tracked_get_mem" c:identifier="vips_tracked_get_mem">
      <doc xml:space="preserve">Returns the number of bytes currently allocated via vips_malloc() and
friends. vips uses this figure to decide when to start dropping cache, see
#VipsOperation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of currently allocated bytes</doc>
        <type name="gsize" c:type="size_t"/>
      </return-value>
    </function>
    <function name="tracked_get_mem_highwater"
              c:identifier="vips_tracked_get_mem_highwater">
      <doc xml:space="preserve">Returns the largest number of bytes simultaneously allocated via
vips_tracked_malloc(). Handy for estimating max memory requirements for a
program.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the largest number of currently allocated bytes</doc>
        <type name="gsize" c:type="size_t"/>
      </return-value>
    </function>
    <function name="tracked_malloc" c:identifier="vips_tracked_malloc">
      <doc xml:space="preserve">Allocate an area of memory that will be tracked by vips_tracked_get_mem()
and friends.

If allocation fails, vips_malloc() returns %NULL and
sets an error message.

You must only free the memory returned with vips_tracked_free().

See also: vips_tracked_free(), vips_malloc().</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory, or %NULL on error.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes to allocate</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_open"
              c:identifier="vips_tracked_open"
              introspectable="0">
      <doc xml:space="preserve">Exactly as open(2), but the number of files current open via
vips_tracked_open() is available via vips_tracked_get_files(). This is used
by the vips operation cache to drop cache when the number of files
available is low.

You must only close the file descriptor with vips_tracked_close().

See also: vips_tracked_close(), vips_tracked_get_files().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a file descriptor, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="pathname" transfer-ownership="none">
          <doc xml:space="preserve">name of file to open</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for open()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">open mode</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="type_depth" c:identifier="vips_type_depth">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find" c:identifier="vips_type_find">
      <doc xml:space="preserve">Search below @basename, return the %GType of the class whose name or
@nickname matches, or 0 for not found.
If @basename is NULL, the whole of #VipsObject is searched.

This function uses a cache, so it should be quick.

See also: vips_class_find()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the %GType of the class, or 0 if the class is not found.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="basename" transfer-ownership="none">
          <doc xml:space="preserve">name of base class</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="nickname" transfer-ownership="none">
          <doc xml:space="preserve">search for a class with this nickname</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_map" c:identifier="vips_type_map" introspectable="0">
      <doc xml:space="preserve">Map over a type's children. Stop when @fn returns non-%NULL
and return that value.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first
non-%NULL value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:space="preserve">call this function for every type</doc>
          <type name="TypeMap2Fn" c:type="VipsTypeMap2Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_map_all"
              c:identifier="vips_type_map_all"
              introspectable="0">
      <doc xml:space="preserve">Map over a type's children, direct and indirect. Stop when @fn returns
non-%NULL and return that value.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first
non-%NULL value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:space="preserve">call this function for every type</doc>
          <type name="TypeMapFn" c:type="VipsTypeMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unpremultiply"
              c:identifier="vips_unpremultiply"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Unpremultiplies any alpha channel.
The final band is taken to be the alpha
and the bands are transformed as:

|[
  alpha = (int) clip( 0, in[in.bands - 1], @max_alpha );
  norm = (double) alpha / @max_alpha;
  if( alpha == 0 )
  	out = [0, ..., 0, alpha];
  else
  	out = [in[0] / norm, ..., in[in.bands - 1] / norm, alpha];
|]

So for an N-band image, the first N - 1 bands are divided by the clipped
and normalised final band, the final band is clipped.
If there is only a single band,
the image is passed through unaltered.

The result is
#VIPS_FORMAT_FLOAT unless the input format is #VIPS_FORMAT_DOUBLE, in which
case the output is double as well.

@max_alpha has the default value 255. You will need to set this to 65535
for images with a 16-bit alpha, or perhaps 1.0 for images with a float
alpha.

Non-complex images only.

See also: vips_premultiply(), vips_flatten().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_area" c:identifier="vips_value_get_area">
      <doc xml:space="preserve">Get the pointer from an area. Don't touch count (area is static).</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">The pointer held by @value.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">get from this value</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="length"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">optionally return length here</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array" c:identifier="vips_value_get_array">
      <doc xml:space="preserve">Return the pointer to the array held by @value.
Optionally return the other properties of the array in @n, @type,
@sizeof_type.

See also: vips_value_set_array().</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">The array address.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="type"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return the type of each element here, optionally</doc>
          <type name="GType" c:type="GType*"/>
        </parameter>
        <parameter name="sizeof_type"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return the sizeof each element here, optionally</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_double"
              c:identifier="vips_value_get_array_double">
      <doc xml:space="preserve">Return the start of the array of doubles held by @value.
optionally return the number of elements in @n.

See also: vips_array_double_new().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The array address.</doc>
        <type name="gdouble" c:type="double*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_image"
              c:identifier="vips_value_get_array_image">
      <doc xml:space="preserve">Return the start of the array of images held by @value.
optionally return the number of elements in @n.

See also: vips_value_set_array_image().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The array address.</doc>
        <type name="Image" c:type="VipsImage**"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_int"
              c:identifier="vips_value_get_array_int">
      <doc xml:space="preserve">Return the start of the array of ints held by @value.
optionally return the number of elements in @n.

See also: vips_array_int_new().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The array address.</doc>
        <type name="gint" c:type="int*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_object"
              c:identifier="vips_value_get_array_object"
              introspectable="0">
      <doc xml:space="preserve">Return the start of the array of %GObject held by @value.
Optionally return the number of elements in @n.

See also: vips_area_new_array_object().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The array address.</doc>
        <type name="GObject.Object" c:type="GObject**"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_blob" c:identifier="vips_value_get_blob">
      <doc xml:space="preserve">Returns the data pointer from a blob. Optionally returns the length too.

blobs are things like ICC profiles or EXIF data. They are relocatable, and
are saved to VIPS files for you coded as base64 inside the XML. They are
copied by copying reference-counted pointers.

See also: vips_value_set_blob()</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">The pointer held by @value.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="length"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">optionally return length of memory area</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_ref_string"
              c:identifier="vips_value_get_ref_string">
      <doc xml:space="preserve">Get the C string held internally by the %GValue.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The C string held by @value.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="length"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return length here, optionally</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_save_string"
              c:identifier="vips_value_get_save_string">
      <doc xml:space="preserve">Get the C string held internally by the GValue.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The C string held by @value.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_is_null" c:identifier="vips_value_is_null">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="psoec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_area" c:identifier="vips_value_set_area">
      <doc xml:space="preserve">Set value to be a ref-counted area of memory with a free function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">set this value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="free_fn"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve">data will be freed with this function</doc>
          <type name="CallbackFn" c:type="VipsCallbackFn"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">set @value to track this pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array" c:identifier="vips_value_set_array">
      <doc xml:space="preserve">Set @value to be an array of things.

This allocates memory but does not
initialise the contents: get the pointer and write instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">%GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of each element</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="sizeof_type" transfer-ownership="none">
          <doc xml:space="preserve">the sizeof each element</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_double"
              c:identifier="vips_value_set_array_double">
      <doc xml:space="preserve">Set @value to hold a copy of @array. Pass in the array length in @n.

See also: vips_array_double_get().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="array"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">array of doubles</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_image"
              c:identifier="vips_value_set_array_image">
      <doc xml:space="preserve">Set @value to hold an array of images. Pass in the array length in @n.

See also: vips_array_image_get().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_int"
              c:identifier="vips_value_set_array_int">
      <doc xml:space="preserve">Set @value to hold a copy of @array. Pass in the array length in @n.

See also: vips_array_int_get().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="array"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">array of ints</doc>
          <array length="2" zero-terminated="0" c:type="int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_object"
              c:identifier="vips_value_set_array_object">
      <doc xml:space="preserve">Set @value to hold an array of %GObject. Pass in the array length in @n.

See also: vips_value_get_array_object().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">%GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_blob" c:identifier="vips_value_set_blob">
      <doc xml:space="preserve">Sets @value to hold a @data. When @value is freed, @data will be
freed with @free_fn. @value also holds a note of the length of the memory
area.

blobs are things like ICC profiles or EXIF data. They are relocatable, and
are saved to VIPS files for you coded as base64 inside the XML. They are
copied by copying reference-counted pointers.

See also: vips_value_get_blob()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="free_fn"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve">free function for @data</doc>
          <type name="CallbackFn" c:type="VipsCallbackFn"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to area of memory</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_ref_string"
              c:identifier="vips_value_set_ref_string">
      <doc xml:space="preserve">Copies the C string @str into @value.

vips_ref_string are immutable C strings that are copied between images by
copying reference-counted pointers, making them much more efficient than
regular %GValue strings.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">%GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">C string to copy into the GValue</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_save_string"
              c:identifier="vips_value_set_save_string">
      <doc xml:space="preserve">Copies the C string into @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">C string to copy into the GValue</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_save_stringf"
              c:identifier="vips_value_set_save_stringf"
              introspectable="0">
      <doc xml:space="preserve">Generates a string and copies it into @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to printf()-formatted @fmt</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="verror" c:identifier="vips_verror" introspectable="0">
      <doc xml:space="preserve">Append a message to the error buffer.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="verror_system"
              c:identifier="vips_verror_system"
              introspectable="0">
      <doc xml:space="preserve">Format the string in the style of printf() and append to the error buffer.
Then create and append a localised message based on the system error code,
usually the value of errno.

See also: vips_error_system().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" transfer-ownership="none">
          <doc xml:space="preserve">the system error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="version" c:identifier="vips_version">
      <doc xml:space="preserve">Get the major, minor or micro library version, with @flag values 0, 1 and
2.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">library version number</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="flag" transfer-ownership="none">
          <doc xml:space="preserve">which field of the version to get</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="version_string" c:identifier="vips_version_string">
      <doc xml:space="preserve">Get the VIPS version as a static string, including a build date and time.
Do not free.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a static version string</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="vinfo" c:identifier="vips_vinfo" introspectable="0">
      <doc xml:space="preserve">Sends a formatted informational message to stderr if the --vips-info flag
has been given to the program, or the environment variable VIPS_INFO has been
defined, or if vips_info_set() has been called.

Informational messages are used to report details about the operation of
functions.

See also: vips_info(), vips_info_set(), vips_warn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="vipsload" c:identifier="vips_vipsload" introspectable="0">
      <doc xml:space="preserve">Read in a vips image.

See also: vips_vipssave().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="vipssave" c:identifier="vips_vipssave" introspectable="0">
      <doc xml:space="preserve">Write @in to @filename in VIPS format.

See also: vips_vipsload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="vwarn" c:identifier="vips_vwarn" introspectable="0">
      <doc xml:space="preserve">Exactly as vips_warn(), but takes a va_list argument.

See also: vips_warn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the warning message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="warn" c:identifier="vips_warn" introspectable="0">
      <doc xml:space="preserve">Sends a formatted warning message to stderr. If you define the
environment variable VIPS_WARNING, these message are supressed.

Warning messages are used to report things like overflow counts.

See also: vips_info(), vips_vwarn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the source of the warning message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpload" c:identifier="vips_webpload" introspectable="0">
      <doc xml:space="preserve">Read a WebP file into a VIPS image.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpload_buffer"
              c:identifier="vips_webpload_buffer"
              introspectable="0">
      <doc xml:space="preserve">Read a WebP-formatted memory block into a VIPS image. Exactly as
vips_webpload(), but read from a memory buffer.

You must not free the buffer while @out is active. The
#VipsObject::postclose signal on @out is a good place to free.

See also: vips_webpload()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">memory area to load</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpsave" c:identifier="vips_webpsave" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

See also: vips_webpload(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">file to write to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpsave_buffer"
              c:identifier="vips_webpsave_buffer"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

See also: vips_webpsave().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="buf"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">return output buffer here</doc>
          <type name="gpointer" c:type="void**"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">return output length here</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpsave_mime"
              c:identifier="vips_webpsave_mime"
              introspectable="0">
      <doc xml:space="preserve">Optional arguments:

As vips_webpsave(), but save as a mime webp on stdout.

See also: vips_webpsave(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="wop" c:identifier="vips_wop" introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH2_WOP on a pair of images. See
vips_math2().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="wop_const"
              c:identifier="vips_wop_const"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH2_WOP on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="wop_const1"
              c:identifier="vips_wop_const1"
              introspectable="0">
      <doc xml:space="preserve">Perform #VIPS_OPERATION_MATH2_WOP on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="wrap" c:identifier="vips_wrap" introspectable="0">
      <doc xml:space="preserve">Optional arguments:

Slice an image up and move the segments about so that the pixel that was
at 0, 0 is now at @x, @y. If @x and @y are not set, they default to the
centre of the image.

See also: vips_embed(), vips_replicate().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="zoom" c:identifier="vips_zoom" introspectable="0">
      <doc xml:space="preserve">Zoom an image by repeating pixels. This is fast nearest-neighbour
zoom.

See also: vips_affine(), vips_subsample().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="xfac" transfer-ownership="none">
          <doc xml:space="preserve">horizontal scale factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="yfac" transfer-ownership="none">
          <doc xml:space="preserve">vertical scale factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
